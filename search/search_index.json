{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"pyNMMS","text":"<p>An automated reasoner for the Non-Monotonic Multi-Succedent (NMMS) propositional sequent calculus from Hlobil &amp; Brandom 2025, Ch. 3.</p> <p>pyNMMS implements a proof search engine for the NMMS sequent calculus, which codifies open reason relations -- consequence relations where Monotonicity and Transitivity can fail.</p>"},{"location":"#why-pynmms","title":"Why pyNMMS?","text":"<p>Traditional logics assume that adding premises never defeats an inference (Monotonicity) and that chaining good inferences always yields good inferences (Transitivity). But real-world reasoning is often defeasible: new information can override previous conclusions.</p> <p>pyNMMS provides:</p> <ul> <li>A material base for encoding defeasible inferences among atomic sentences</li> <li>Backward proof search implementing all 8 propositional NMMS rules</li> <li>Supraclassicality: all classically valid sequents remain derivable</li> <li>A Tell/Ask CLI and interactive REPL for exploring reason relations</li> <li>Full proof traces for understanding derivations</li> <li>Ontology extension with schema-level macros for material inferential commitments and incompatibilities (subClassOf, range, domain, subPropertyOf, disjointWith, disjointProperties)</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from pynmms import MaterialBase, NMMSReasoner\n\nbase = MaterialBase(\n    language={\"A\", \"B\", \"C\"},\n    consequences={\n        (frozenset({\"A\"}), frozenset({\"B\"})),  # A |~ B\n        (frozenset({\"B\"}), frozenset({\"C\"})),  # B |~ C\n    },\n)\nreasoner = NMMSReasoner(base)\n\nreasoner.query(frozenset({\"A\"}), frozenset({\"B\"}))  # True (base consequence)\nreasoner.query(frozenset({\"A\"}), frozenset({\"C\"}))  # False (nontransitive!)\nreasoner.query(frozenset({\"A\", \"C\"}), frozenset({\"B\"}))  # False (nonmonotonic!)\nreasoner.query(frozenset(), frozenset({\"A | ~A\"}))  # True (supraclassical)\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pyNMMS\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<pre><code>pip install pyNMMS\n</code></pre> <p>For development:</p> <pre><code>git clone https://github.com/bradleypallen/pyNMMS.git\ncd pyNMMS\npip install -e \".[dev]\"\n</code></pre>"},{"location":"getting-started/#your-first-material-base","title":"Your First Material Base","text":"<p>A material base encodes defeasible material inferences among atomic sentences.</p> <pre><code>from pynmms import MaterialBase, NMMSReasoner\n\n# Create a base: \"rain\" defeasibly implies \"wet ground\"\nbase = MaterialBase(\n    language={\"rain\", \"wet_ground\", \"covered\"},\n    consequences={\n        (frozenset({\"rain\"}), frozenset({\"wet_ground\"})),\n    },\n)\n</code></pre>"},{"location":"getting-started/#querying-derivability","title":"Querying Derivability","text":"<pre><code>reasoner = NMMSReasoner(base)\n\n# Does rain derive wet ground?\nresult = reasoner.derives(frozenset({\"rain\"}), frozenset({\"wet_ground\"}))\nprint(result.derivable)  # True\n\n# Nonmonotonicity: adding \"covered\" defeats the inference\nresult = reasoner.derives(\n    frozenset({\"rain\", \"covered\"}),\n    frozenset({\"wet_ground\"})\n)\nprint(result.derivable)  # False \u2014 no weakening!\n</code></pre>"},{"location":"getting-started/#using-the-cli","title":"Using the CLI","text":"<pre><code># Create a base\npynmms tell -b mybase.json --create \"rain |~ wet_ground\"\n\n# Query it\npynmms ask -b mybase.json \"rain =&gt; wet_ground\"        # DERIVABLE\npynmms ask -b mybase.json \"rain, covered =&gt; wet_ground\"  # NOT DERIVABLE\n\n# Interactive REPL\npynmms repl -b mybase.json\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Key Concepts \u2014 understand material bases, nonmonotonicity, and sequents</li> <li>Proof Search \u2014 how the reasoner works and how to read traces</li> <li>CLI Usage \u2014 full guide to the Tell/Ask CLI and REPL</li> </ul>"},{"location":"api/base/","title":"MaterialBase","text":""},{"location":"api/base/#pynmms.base.MaterialBase","title":"<code>pynmms.base.MaterialBase</code>  <code>dataclass</code>","text":"<p>A material base B =  for propositional NMMS. <p>Parameters:</p> Name Type Description Default <code>language</code> <code>set[str] | frozenset[str] | None</code> <p>Set of atomic sentence strings comprising L_B.</p> <code>None</code> <code>consequences</code> <code>set[Sequent] | set[tuple[frozenset[str], frozenset[str]]] | None</code> <p>Set of (antecedent, consequent) sequent pairs comprising |~_B.</p> <code>None</code> Source code in <code>pynmms/base.py</code> <pre><code>@dataclass\nclass MaterialBase:\n    \"\"\"A material base B = &lt;L_B, |~_B&gt; for propositional NMMS.\n\n    Parameters:\n        language: Set of atomic sentence strings comprising L_B.\n        consequences: Set of (antecedent, consequent) sequent pairs comprising |~_B.\n    \"\"\"\n\n    _language: set[str] = field(default_factory=set)\n    _consequences: set[Sequent] = field(default_factory=set)\n\n    def __init__(\n        self,\n        language: set[str] | frozenset[str] | None = None,\n        consequences: (\n            set[Sequent]\n            | set[tuple[frozenset[str], frozenset[str]]]\n            | None\n        ) = None,\n        annotations: dict[str, str] | None = None,\n    ) -&gt; None:\n        self._language: set[str] = set(language) if language else set()\n        self._consequences: set[Sequent] = set()\n        self._annotations: dict[str, str] = dict(annotations) if annotations else {}\n\n        # Validate all language atoms\n        for s in self._language:\n            _validate_atomic(s, \"Material base language\")\n\n        # Validate and store consequences\n        if consequences:\n            for gamma, delta in consequences:\n                for s in gamma | delta:\n                    _validate_atomic(s, \"Material base consequence\")\n                self._consequences.add((gamma, delta))\n\n        logger.debug(\n            \"MaterialBase created: %d atoms, %d consequences\",\n            len(self._language),\n            len(self._consequences),\n        )\n\n    # --- Read-only properties ---\n\n    @property\n    def language(self) -&gt; frozenset[str]:\n        \"\"\"The atomic language L_B (read-only view).\"\"\"\n        return frozenset(self._language)\n\n    @property\n    def consequences(self) -&gt; frozenset[Sequent]:\n        \"\"\"The base consequence relation |~_B (read-only view).\"\"\"\n        return frozenset(self._consequences)\n\n    @property\n    def annotations(self) -&gt; dict[str, str]:\n        \"\"\"Atom annotations (read-only view).\"\"\"\n        return dict(self._annotations)\n\n    # --- Mutation ---\n\n    def add_atom(self, s: str) -&gt; None:\n        \"\"\"Add an atomic sentence to the language L_B.\"\"\"\n        _validate_atomic(s, \"add_atom\")\n        self._language.add(s)\n        logger.debug(\"Added atom: %s\", s)\n\n    def annotate(self, atom: str, description: str) -&gt; None:\n        \"\"\"Attach a natural-language description to an atom.\"\"\"\n        self._annotations[atom] = description\n        logger.debug(\"Annotated atom %s: %s\", atom, description)\n\n    def add_consequence(self, antecedent: frozenset[str], consequent: frozenset[str]) -&gt; None:\n        \"\"\"Add a base consequence Gamma |~_B Delta.\n\n        All sentences in *antecedent* and *consequent* must be atomic. They are\n        also implicitly added to the language.\n        \"\"\"\n        for s in antecedent | consequent:\n            _validate_atomic(s, \"add_consequence\")\n            self._language.add(s)\n        self._consequences.add((antecedent, consequent))\n        logger.debug(\"Added consequence: %s |~ %s\", set(antecedent), set(consequent))\n\n    # --- Axiom check ---\n\n    def is_axiom(self, gamma: frozenset[str], delta: frozenset[str]) -&gt; bool:\n        \"\"\"Check if Gamma =&gt; Delta is an axiom of NMMS_B.\n\n        Ax1 (Containment): Gamma \u2229 Delta \u2260 \u2205.\n        Ax2 (Base consequence): (Gamma, Delta) \u2208 |~_B exactly.\n\n        No Weakening: the base relation uses exact syntactic match.\n        \"\"\"\n        # Ax1: Containment\n        if gamma &amp; delta:\n            return True\n        # Ax2: Explicit base consequence (exact match)\n        if (gamma, delta) in self._consequences:\n            return True\n        return False\n\n    # --- Serialization ---\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Serialize to a JSON-compatible dict.\"\"\"\n        d: dict = {\n            \"language\": sorted(self._language),\n            \"consequences\": [\n                {\n                    \"antecedent\": sorted(gamma),\n                    \"consequent\": sorted(delta),\n                }\n                for gamma, delta in sorted(\n                    self._consequences, key=lambda s: (sorted(s[0]), sorted(s[1]))\n                )\n            ],\n        }\n        if self._annotations:\n            d[\"annotations\"] = dict(sorted(self._annotations.items()))\n        return d\n\n    @classmethod\n    def from_dict(cls, data: dict) -&gt; MaterialBase:\n        \"\"\"Deserialize from a dict (as produced by ``to_dict``).\"\"\"\n        language = set(data.get(\"language\", []))\n        consequences: set[Sequent] = set()\n        for entry in data.get(\"consequences\", []):\n            gamma = frozenset(entry[\"antecedent\"])\n            delta = frozenset(entry[\"consequent\"])\n            consequences.add((gamma, delta))\n        annotations = data.get(\"annotations\", {})\n        return cls(language=language, consequences=consequences, annotations=annotations)\n\n    def to_file(self, path: str | Path) -&gt; None:\n        \"\"\"Write the base to a JSON file.\"\"\"\n        with open(path, \"w\") as f:\n            json.dump(self.to_dict(), f, indent=2)\n        logger.debug(\"Saved base to %s\", path)\n\n    @classmethod\n    def from_file(cls, path: str | Path) -&gt; MaterialBase:\n        \"\"\"Load a base from a JSON file.\"\"\"\n        with open(path) as f:\n            data = json.load(f)\n        logger.debug(\"Loaded base from %s\", path)\n        return cls.from_dict(data)\n</code></pre>"},{"location":"api/base/#pynmms.base.MaterialBase.language","title":"<code>language</code>  <code>property</code>","text":"<p>The atomic language L_B (read-only view).</p>"},{"location":"api/base/#pynmms.base.MaterialBase.consequences","title":"<code>consequences</code>  <code>property</code>","text":"<p>The base consequence relation |~_B (read-only view).</p>"},{"location":"api/base/#pynmms.base.MaterialBase.__init__","title":"<code>__init__(language=None, consequences=None, annotations=None)</code>","text":"Source code in <code>pynmms/base.py</code> <pre><code>def __init__(\n    self,\n    language: set[str] | frozenset[str] | None = None,\n    consequences: (\n        set[Sequent]\n        | set[tuple[frozenset[str], frozenset[str]]]\n        | None\n    ) = None,\n    annotations: dict[str, str] | None = None,\n) -&gt; None:\n    self._language: set[str] = set(language) if language else set()\n    self._consequences: set[Sequent] = set()\n    self._annotations: dict[str, str] = dict(annotations) if annotations else {}\n\n    # Validate all language atoms\n    for s in self._language:\n        _validate_atomic(s, \"Material base language\")\n\n    # Validate and store consequences\n    if consequences:\n        for gamma, delta in consequences:\n            for s in gamma | delta:\n                _validate_atomic(s, \"Material base consequence\")\n            self._consequences.add((gamma, delta))\n\n    logger.debug(\n        \"MaterialBase created: %d atoms, %d consequences\",\n        len(self._language),\n        len(self._consequences),\n    )\n</code></pre>"},{"location":"api/base/#pynmms.base.MaterialBase.add_atom","title":"<code>add_atom(s)</code>","text":"<p>Add an atomic sentence to the language L_B.</p> Source code in <code>pynmms/base.py</code> <pre><code>def add_atom(self, s: str) -&gt; None:\n    \"\"\"Add an atomic sentence to the language L_B.\"\"\"\n    _validate_atomic(s, \"add_atom\")\n    self._language.add(s)\n    logger.debug(\"Added atom: %s\", s)\n</code></pre>"},{"location":"api/base/#pynmms.base.MaterialBase.add_consequence","title":"<code>add_consequence(antecedent, consequent)</code>","text":"<p>Add a base consequence Gamma |~_B Delta.</p> <p>All sentences in antecedent and consequent must be atomic. They are also implicitly added to the language.</p> Source code in <code>pynmms/base.py</code> <pre><code>def add_consequence(self, antecedent: frozenset[str], consequent: frozenset[str]) -&gt; None:\n    \"\"\"Add a base consequence Gamma |~_B Delta.\n\n    All sentences in *antecedent* and *consequent* must be atomic. They are\n    also implicitly added to the language.\n    \"\"\"\n    for s in antecedent | consequent:\n        _validate_atomic(s, \"add_consequence\")\n        self._language.add(s)\n    self._consequences.add((antecedent, consequent))\n    logger.debug(\"Added consequence: %s |~ %s\", set(antecedent), set(consequent))\n</code></pre>"},{"location":"api/base/#pynmms.base.MaterialBase.is_axiom","title":"<code>is_axiom(gamma, delta)</code>","text":"<p>Check if Gamma =&gt; Delta is an axiom of NMMS_B.</p> <p>Ax1 (Containment): Gamma \u2229 Delta \u2260 \u2205. Ax2 (Base consequence): (Gamma, Delta) \u2208 |~_B exactly.</p> <p>No Weakening: the base relation uses exact syntactic match.</p> Source code in <code>pynmms/base.py</code> <pre><code>def is_axiom(self, gamma: frozenset[str], delta: frozenset[str]) -&gt; bool:\n    \"\"\"Check if Gamma =&gt; Delta is an axiom of NMMS_B.\n\n    Ax1 (Containment): Gamma \u2229 Delta \u2260 \u2205.\n    Ax2 (Base consequence): (Gamma, Delta) \u2208 |~_B exactly.\n\n    No Weakening: the base relation uses exact syntactic match.\n    \"\"\"\n    # Ax1: Containment\n    if gamma &amp; delta:\n        return True\n    # Ax2: Explicit base consequence (exact match)\n    if (gamma, delta) in self._consequences:\n        return True\n    return False\n</code></pre>"},{"location":"api/base/#pynmms.base.MaterialBase.to_dict","title":"<code>to_dict()</code>","text":"<p>Serialize to a JSON-compatible dict.</p> Source code in <code>pynmms/base.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Serialize to a JSON-compatible dict.\"\"\"\n    d: dict = {\n        \"language\": sorted(self._language),\n        \"consequences\": [\n            {\n                \"antecedent\": sorted(gamma),\n                \"consequent\": sorted(delta),\n            }\n            for gamma, delta in sorted(\n                self._consequences, key=lambda s: (sorted(s[0]), sorted(s[1]))\n            )\n        ],\n    }\n    if self._annotations:\n        d[\"annotations\"] = dict(sorted(self._annotations.items()))\n    return d\n</code></pre>"},{"location":"api/base/#pynmms.base.MaterialBase.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Deserialize from a dict (as produced by <code>to_dict</code>).</p> Source code in <code>pynmms/base.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict) -&gt; MaterialBase:\n    \"\"\"Deserialize from a dict (as produced by ``to_dict``).\"\"\"\n    language = set(data.get(\"language\", []))\n    consequences: set[Sequent] = set()\n    for entry in data.get(\"consequences\", []):\n        gamma = frozenset(entry[\"antecedent\"])\n        delta = frozenset(entry[\"consequent\"])\n        consequences.add((gamma, delta))\n    annotations = data.get(\"annotations\", {})\n    return cls(language=language, consequences=consequences, annotations=annotations)\n</code></pre>"},{"location":"api/base/#pynmms.base.MaterialBase.to_file","title":"<code>to_file(path)</code>","text":"<p>Write the base to a JSON file.</p> Source code in <code>pynmms/base.py</code> <pre><code>def to_file(self, path: str | Path) -&gt; None:\n    \"\"\"Write the base to a JSON file.\"\"\"\n    with open(path, \"w\") as f:\n        json.dump(self.to_dict(), f, indent=2)\n    logger.debug(\"Saved base to %s\", path)\n</code></pre>"},{"location":"api/base/#pynmms.base.MaterialBase.from_file","title":"<code>from_file(path)</code>  <code>classmethod</code>","text":"<p>Load a base from a JSON file.</p> Source code in <code>pynmms/base.py</code> <pre><code>@classmethod\ndef from_file(cls, path: str | Path) -&gt; MaterialBase:\n    \"\"\"Load a base from a JSON file.\"\"\"\n    with open(path) as f:\n        data = json.load(f)\n    logger.debug(\"Loaded base from %s\", path)\n    return cls.from_dict(data)\n</code></pre>"},{"location":"api/onto-base/","title":"Ontology Material Base","text":""},{"location":"api/onto-base/#pynmms.onto.base","title":"<code>pynmms.onto.base</code>","text":"<p>Ontology Material Base -- ontology axiom schemas for NMMS.</p> <p>Extends the propositional <code>MaterialBase</code> with ontology-style vocabulary tracking (individuals, concepts, roles) and six defeasible axiom schema types: subClassOf, range, domain, subPropertyOf, disjointWith, disjointProperties.</p>"},{"location":"api/onto-base/#pynmms.onto.base.OntoMaterialBase","title":"<code>OntoMaterialBase</code>","text":"<p>               Bases: <code>MaterialBase</code></p> <p>A material base for NMMS with ontology axiom schemas.</p> <p>Extends <code>MaterialBase</code> to accept concept/role assertions as atomic, track vocabulary (individuals, concepts, roles), and support six ontology axiom schema types: subClassOf, range, domain, subPropertyOf, disjointWith, disjointProperties.</p> <p>Schemas are evaluated lazily at query time -- not grounded over known individuals. All use exact match (no weakening) to preserve nonmonotonicity.</p> Source code in <code>pynmms/onto/base.py</code> <pre><code>class OntoMaterialBase(MaterialBase):\n    \"\"\"A material base for NMMS with ontology axiom schemas.\n\n    Extends ``MaterialBase`` to accept concept/role assertions as atomic,\n    track vocabulary (individuals, concepts, roles), and support six\n    ontology axiom schema types: subClassOf, range, domain, subPropertyOf,\n    disjointWith, disjointProperties.\n\n    Schemas are evaluated lazily at query time -- not grounded over known\n    individuals. All use exact match (no weakening) to preserve\n    nonmonotonicity.\n    \"\"\"\n\n    def __init__(\n        self,\n        language: set[str] | frozenset[str] | None = None,\n        consequences: (\n            set[Sequent] | set[tuple[frozenset[str], frozenset[str]]] | None\n        ) = None,\n        annotations: dict[str, str] | None = None,\n    ) -&gt; None:\n        self._individuals: set[str] = set()\n        self._concepts: set[str] = set()\n        self._roles: set[str] = set()\n        self._onto_schemas: list[tuple[str, str, str, str | None]] = []\n        # Temporarily bypass parent validation -- we override _validate\n        self._onto_language: set[str] = set(language) if language else set()\n        self._onto_consequences: set[Sequent] = set()\n\n        # Validate onto-atomic\n        for s in self._onto_language:\n            _validate_onto_atomic(s, \"Ontology material base language\")\n            self._extract_vocab(s)\n\n        if consequences:\n            for gamma, delta in consequences:\n                for s in gamma | delta:\n                    _validate_onto_atomic(s, \"Ontology material base consequence\")\n                    self._extract_vocab(s)\n                self._onto_consequences.add((gamma, delta))\n\n        # Initialize parent with empty sets -- we manage storage ourselves\n        super().__init__(annotations=annotations)\n        self._language = self._onto_language\n        self._consequences = self._onto_consequences\n\n        logger.debug(\n            \"OntoMaterialBase created: %d atoms, %d consequences, \"\n            \"%d individuals, %d concepts, %d roles\",\n            len(self._language),\n            len(self._consequences),\n            len(self._individuals),\n            len(self._concepts),\n            len(self._roles),\n        )\n\n    def _extract_vocab(self, s: str) -&gt; None:\n        \"\"\"Extract vocabulary (individuals, concepts, roles) from a sentence.\"\"\"\n        parsed = parse_onto_sentence(s)\n        if isinstance(parsed, OntoSentence):\n            if parsed.type == ATOM_CONCEPT:\n                self._individuals.add(parsed.individual)  # type: ignore[arg-type]\n                self._concepts.add(parsed.concept)  # type: ignore[arg-type]\n            elif parsed.type == ATOM_ROLE:\n                self._individuals.add(parsed.arg1)  # type: ignore[arg-type]\n                self._individuals.add(parsed.arg2)  # type: ignore[arg-type]\n                self._roles.add(parsed.role)  # type: ignore[arg-type]\n\n    # --- Read-only properties ---\n\n    @property\n    def individuals(self) -&gt; frozenset[str]:\n        \"\"\"Known individuals (read-only).\"\"\"\n        return frozenset(self._individuals)\n\n    @property\n    def concepts(self) -&gt; frozenset[str]:\n        \"\"\"Known concepts (read-only).\"\"\"\n        return frozenset(self._concepts)\n\n    @property\n    def roles(self) -&gt; frozenset[str]:\n        \"\"\"Known roles (read-only).\"\"\"\n        return frozenset(self._roles)\n\n    @property\n    def onto_schemas(self) -&gt; list[tuple[str, str, str, str | None]]:\n        \"\"\"Ontology schemas (read-only copy).\"\"\"\n        return list(self._onto_schemas)\n\n    # --- Mutation ---\n\n    def add_atom(self, s: str) -&gt; None:\n        \"\"\"Add an onto-atomic sentence to the language.\"\"\"\n        _validate_onto_atomic(s, \"add_atom\")\n        self._language.add(s)\n        self._extract_vocab(s)\n        logger.debug(\"Added atom: %s\", s)\n\n    def add_consequence(\n        self, antecedent: frozenset[str], consequent: frozenset[str]\n    ) -&gt; None:\n        \"\"\"Add a base consequence. All sentences must be onto-atomic.\"\"\"\n        for s in antecedent | consequent:\n            _validate_onto_atomic(s, \"add_consequence\")\n            self._language.add(s)\n            self._extract_vocab(s)\n        self._consequences.add((antecedent, consequent))\n        logger.debug(\"Added consequence: %s |~ %s\", set(antecedent), set(consequent))\n\n    def add_individual(self, role: str, subject: str, obj: str) -&gt; None:\n        \"\"\"Add a role assertion R(subject, obj) to the language.\"\"\"\n        role_assertion = make_role_assertion(role, subject, obj)\n        self._language.add(role_assertion)\n        self._extract_vocab(role_assertion)\n        logger.debug(\"Added individual: %s\", role_assertion)\n\n    # --- Ontology schema registration ---\n\n    def register_subclass(\n        self,\n        sub_concept: str,\n        super_concept: str,\n        annotation: str | None = None,\n    ) -&gt; None:\n        \"\"\"Register subClassOf schema: {sub(x)} |~ {super(x)} for any x.\n\n        Stored lazily -- not grounded over known individuals.\n        \"\"\"\n        self._onto_schemas.append((\"subClassOf\", sub_concept, super_concept, annotation))\n        logger.debug(\n            \"Registered subClassOf schema: %s \u2291 %s\", sub_concept, super_concept\n        )\n\n    def register_range(\n        self,\n        role: str,\n        concept: str,\n        annotation: str | None = None,\n    ) -&gt; None:\n        \"\"\"Register range schema: {R(x,y)} |~ {C(y)} for any x, y.\n\n        Stored lazily -- not grounded over known individuals.\n        \"\"\"\n        self._onto_schemas.append((\"range\", role, concept, annotation))\n        logger.debug(\"Registered range schema: range(%s) = %s\", role, concept)\n\n    def register_domain(\n        self,\n        role: str,\n        concept: str,\n        annotation: str | None = None,\n    ) -&gt; None:\n        \"\"\"Register domain schema: {R(x,y)} |~ {C(x)} for any x, y.\n\n        Stored lazily -- not grounded over known individuals.\n        \"\"\"\n        self._onto_schemas.append((\"domain\", role, concept, annotation))\n        logger.debug(\"Registered domain schema: domain(%s) = %s\", role, concept)\n\n    def register_subproperty(\n        self,\n        sub_role: str,\n        super_role: str,\n        annotation: str | None = None,\n    ) -&gt; None:\n        \"\"\"Register subPropertyOf schema: {R(x,y)} |~ {S(x,y)} for any x, y.\n\n        Stored lazily -- not grounded over known individuals.\n        \"\"\"\n        self._onto_schemas.append((\"subPropertyOf\", sub_role, super_role, annotation))\n        logger.debug(\n            \"Registered subPropertyOf schema: %s \u2291 %s\", sub_role, super_role\n        )\n\n    def register_disjoint(\n        self,\n        concept1: str,\n        concept2: str,\n        annotation: str | None = None,\n    ) -&gt; None:\n        \"\"\"Register disjointWith schema: {C(x), D(x)} |~_B {} for any x.\n\n        Material incompatibility between two concepts. Stored lazily.\n        \"\"\"\n        self._onto_schemas.append((\"disjointWith\", concept1, concept2, annotation))\n        logger.debug(\n            \"Registered disjointWith schema: %s \u22a5 %s\", concept1, concept2\n        )\n\n    def register_disjoint_properties(\n        self,\n        role1: str,\n        role2: str,\n        annotation: str | None = None,\n    ) -&gt; None:\n        \"\"\"Register disjointProperties schema: {R(x,y), S(x,y)} |~_B {} for any x, y.\n\n        Material incompatibility between two roles. Stored lazily.\n        \"\"\"\n        self._onto_schemas.append((\"disjointProperties\", role1, role2, annotation))\n        logger.debug(\n            \"Registered disjointProperties schema: %s \u22a5 %s\", role1, role2\n        )\n\n    # --- Axiom check (overrides parent) ---\n\n    def is_axiom(self, gamma: frozenset[str], delta: frozenset[str]) -&gt; bool:\n        \"\"\"Check if Gamma =&gt; Delta is an axiom.\n\n        Ax1 (Containment): Gamma &amp; Delta != empty.\n        Ax2 (Base consequence): (Gamma, Delta) in |~_B exactly.\n        Ax3 (Ontology schema consequence): matches a lazy ontology schema.\n        \"\"\"\n        # Ax1: Containment\n        if gamma &amp; delta:\n            return True\n        # Ax2: Explicit base consequence (exact match)\n        if (gamma, delta) in self._consequences:\n            return True\n        # Ax3: Ontology schema evaluation\n        if self._onto_schemas and self._check_onto_schemas(gamma, delta):\n            return True\n        return False\n\n    def _check_onto_schemas(\n        self, gamma: frozenset[str], delta: frozenset[str]\n    ) -&gt; bool:\n        \"\"\"Check if any ontology schema makes gamma |~ delta hold.\n\n        Exact match (no weakening) preserves nonmonotonicity.\n        Inference schemas: len(gamma) == 1, len(delta) == 1.\n        Incompatibility schemas: len(gamma) == 2, len(delta) == 0.\n        \"\"\"\n        # --- Inference schemas: singleton antecedent, singleton consequent ---\n        if len(gamma) == 1 and len(delta) == 1:\n            gamma_str = next(iter(gamma))\n            delta_str = next(iter(delta))\n\n            try:\n                gamma_parsed = parse_onto_sentence(gamma_str)\n                delta_parsed = parse_onto_sentence(delta_str)\n            except ValueError:\n                return False\n\n            if not isinstance(gamma_parsed, OntoSentence) or not isinstance(\n                delta_parsed, OntoSentence\n            ):\n                return False\n\n            for schema_type, arg1, arg2, _annotation in self._onto_schemas:\n                if schema_type == \"subClassOf\":\n                    # {C(x)} |~ {D(x)} -- same individual\n                    if (\n                        gamma_parsed.type == ATOM_CONCEPT\n                        and delta_parsed.type == ATOM_CONCEPT\n                        and gamma_parsed.concept == arg1\n                        and delta_parsed.concept == arg2\n                        and gamma_parsed.individual == delta_parsed.individual\n                    ):\n                        return True\n\n                elif schema_type == \"range\":\n                    # {R(x,y)} |~ {C(y)} -- role.arg2 == concept.individual\n                    if (\n                        gamma_parsed.type == ATOM_ROLE\n                        and delta_parsed.type == ATOM_CONCEPT\n                        and gamma_parsed.role == arg1\n                        and delta_parsed.concept == arg2\n                        and gamma_parsed.arg2 == delta_parsed.individual\n                    ):\n                        return True\n\n                elif schema_type == \"domain\":\n                    # {R(x,y)} |~ {C(x)} -- role.arg1 == concept.individual\n                    if (\n                        gamma_parsed.type == ATOM_ROLE\n                        and delta_parsed.type == ATOM_CONCEPT\n                        and gamma_parsed.role == arg1\n                        and delta_parsed.concept == arg2\n                        and gamma_parsed.arg1 == delta_parsed.individual\n                    ):\n                        return True\n\n                elif schema_type == \"subPropertyOf\":\n                    # {R(x,y)} |~ {S(x,y)} -- same arg1, same arg2\n                    if (\n                        gamma_parsed.type == ATOM_ROLE\n                        and delta_parsed.type == ATOM_ROLE\n                        and gamma_parsed.role == arg1\n                        and delta_parsed.role == arg2\n                        and gamma_parsed.arg1 == delta_parsed.arg1\n                        and gamma_parsed.arg2 == delta_parsed.arg2\n                    ):\n                        return True\n\n            return False\n\n        # --- Incompatibility schemas: two-element antecedent, empty consequent ---\n        if len(gamma) == 2 and len(delta) == 0:\n            gamma_list = sorted(gamma)  # deterministic iteration\n            try:\n                parsed_0 = parse_onto_sentence(gamma_list[0])\n                parsed_1 = parse_onto_sentence(gamma_list[1])\n            except ValueError:\n                return False\n\n            if not isinstance(parsed_0, OntoSentence) or not isinstance(\n                parsed_1, OntoSentence\n            ):\n                return False\n\n            for schema_type, arg1, arg2, _annotation in self._onto_schemas:\n                if schema_type == \"disjointWith\":\n                    # Both concept assertions, same individual, concepts match {arg1, arg2}\n                    if (\n                        parsed_0.type == ATOM_CONCEPT\n                        and parsed_1.type == ATOM_CONCEPT\n                        and parsed_0.individual == parsed_1.individual\n                        and {parsed_0.concept, parsed_1.concept} == {arg1, arg2}\n                    ):\n                        return True\n\n                elif schema_type == \"disjointProperties\":\n                    # Both role assertions, same args, roles match {arg1, arg2}\n                    if (\n                        parsed_0.type == ATOM_ROLE\n                        and parsed_1.type == ATOM_ROLE\n                        and parsed_0.arg1 == parsed_1.arg1\n                        and parsed_0.arg2 == parsed_1.arg2\n                        and {parsed_0.role, parsed_1.role} == {arg1, arg2}\n                    ):\n                        return True\n\n            return False\n\n        return False\n\n    # --- Serialization ---\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Serialize to a JSON-compatible dict, including ontology schemas.\"\"\"\n        base_dict = super().to_dict()\n        base_dict[\"individuals\"] = sorted(self._individuals)\n        base_dict[\"concepts\"] = sorted(self._concepts)\n        base_dict[\"roles\"] = sorted(self._roles)\n        base_dict[\"onto_schemas\"] = [\n            {\n                \"type\": schema_type,\n                \"arg1\": arg1,\n                \"arg2\": arg2,\n                **({\"annotation\": annotation} if annotation else {}),\n            }\n            for schema_type, arg1, arg2, annotation in self._onto_schemas\n        ]\n        return base_dict\n\n    @classmethod\n    def from_dict(cls, data: dict) -&gt; OntoMaterialBase:\n        \"\"\"Deserialize from a dict (as produced by ``to_dict``).\"\"\"\n        language = set(data.get(\"language\", []))\n        consequences: set[Sequent] = set()\n        for entry in data.get(\"consequences\", []):\n            gamma = frozenset(entry[\"antecedent\"])\n            delta = frozenset(entry[\"consequent\"])\n            consequences.add((gamma, delta))\n        annotations = data.get(\"annotations\", {})\n\n        base = cls(language=language, consequences=consequences, annotations=annotations)\n\n        # Restore ontology schemas\n        schemas_data = data.get(\"onto_schemas\", [])\n        for schema in schemas_data:\n            base._onto_schemas.append((\n                schema[\"type\"],\n                schema[\"arg1\"],\n                schema[\"arg2\"],\n                schema.get(\"annotation\"),\n            ))\n\n        return base\n\n    def to_file(self, path: str | Path) -&gt; None:\n        \"\"\"Write the base to a JSON file.\"\"\"\n        with open(path, \"w\") as f:\n            json.dump(self.to_dict(), f, indent=2)\n        logger.debug(\"Saved ontology base to %s\", path)\n\n    @classmethod\n    def from_file(cls, path: str | Path) -&gt; OntoMaterialBase:\n        \"\"\"Load a base from a JSON file.\"\"\"\n        with open(path) as f:\n            data = json.load(f)\n        logger.debug(\"Loaded ontology base from %s\", path)\n        return cls.from_dict(data)\n</code></pre>"},{"location":"api/onto-base/#pynmms.onto.base.OntoMaterialBase.concepts","title":"<code>concepts</code>  <code>property</code>","text":"<p>Known concepts (read-only).</p>"},{"location":"api/onto-base/#pynmms.onto.base.OntoMaterialBase.individuals","title":"<code>individuals</code>  <code>property</code>","text":"<p>Known individuals (read-only).</p>"},{"location":"api/onto-base/#pynmms.onto.base.OntoMaterialBase.onto_schemas","title":"<code>onto_schemas</code>  <code>property</code>","text":"<p>Ontology schemas (read-only copy).</p>"},{"location":"api/onto-base/#pynmms.onto.base.OntoMaterialBase.roles","title":"<code>roles</code>  <code>property</code>","text":"<p>Known roles (read-only).</p>"},{"location":"api/onto-base/#pynmms.onto.base.OntoMaterialBase.add_atom","title":"<code>add_atom(s)</code>","text":"<p>Add an onto-atomic sentence to the language.</p> Source code in <code>pynmms/onto/base.py</code> <pre><code>def add_atom(self, s: str) -&gt; None:\n    \"\"\"Add an onto-atomic sentence to the language.\"\"\"\n    _validate_onto_atomic(s, \"add_atom\")\n    self._language.add(s)\n    self._extract_vocab(s)\n    logger.debug(\"Added atom: %s\", s)\n</code></pre>"},{"location":"api/onto-base/#pynmms.onto.base.OntoMaterialBase.add_consequence","title":"<code>add_consequence(antecedent, consequent)</code>","text":"<p>Add a base consequence. All sentences must be onto-atomic.</p> Source code in <code>pynmms/onto/base.py</code> <pre><code>def add_consequence(\n    self, antecedent: frozenset[str], consequent: frozenset[str]\n) -&gt; None:\n    \"\"\"Add a base consequence. All sentences must be onto-atomic.\"\"\"\n    for s in antecedent | consequent:\n        _validate_onto_atomic(s, \"add_consequence\")\n        self._language.add(s)\n        self._extract_vocab(s)\n    self._consequences.add((antecedent, consequent))\n    logger.debug(\"Added consequence: %s |~ %s\", set(antecedent), set(consequent))\n</code></pre>"},{"location":"api/onto-base/#pynmms.onto.base.OntoMaterialBase.add_individual","title":"<code>add_individual(role, subject, obj)</code>","text":"<p>Add a role assertion R(subject, obj) to the language.</p> Source code in <code>pynmms/onto/base.py</code> <pre><code>def add_individual(self, role: str, subject: str, obj: str) -&gt; None:\n    \"\"\"Add a role assertion R(subject, obj) to the language.\"\"\"\n    role_assertion = make_role_assertion(role, subject, obj)\n    self._language.add(role_assertion)\n    self._extract_vocab(role_assertion)\n    logger.debug(\"Added individual: %s\", role_assertion)\n</code></pre>"},{"location":"api/onto-base/#pynmms.onto.base.OntoMaterialBase.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Deserialize from a dict (as produced by <code>to_dict</code>).</p> Source code in <code>pynmms/onto/base.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict) -&gt; OntoMaterialBase:\n    \"\"\"Deserialize from a dict (as produced by ``to_dict``).\"\"\"\n    language = set(data.get(\"language\", []))\n    consequences: set[Sequent] = set()\n    for entry in data.get(\"consequences\", []):\n        gamma = frozenset(entry[\"antecedent\"])\n        delta = frozenset(entry[\"consequent\"])\n        consequences.add((gamma, delta))\n    annotations = data.get(\"annotations\", {})\n\n    base = cls(language=language, consequences=consequences, annotations=annotations)\n\n    # Restore ontology schemas\n    schemas_data = data.get(\"onto_schemas\", [])\n    for schema in schemas_data:\n        base._onto_schemas.append((\n            schema[\"type\"],\n            schema[\"arg1\"],\n            schema[\"arg2\"],\n            schema.get(\"annotation\"),\n        ))\n\n    return base\n</code></pre>"},{"location":"api/onto-base/#pynmms.onto.base.OntoMaterialBase.from_file","title":"<code>from_file(path)</code>  <code>classmethod</code>","text":"<p>Load a base from a JSON file.</p> Source code in <code>pynmms/onto/base.py</code> <pre><code>@classmethod\ndef from_file(cls, path: str | Path) -&gt; OntoMaterialBase:\n    \"\"\"Load a base from a JSON file.\"\"\"\n    with open(path) as f:\n        data = json.load(f)\n    logger.debug(\"Loaded ontology base from %s\", path)\n    return cls.from_dict(data)\n</code></pre>"},{"location":"api/onto-base/#pynmms.onto.base.OntoMaterialBase.is_axiom","title":"<code>is_axiom(gamma, delta)</code>","text":"<p>Check if Gamma =&gt; Delta is an axiom.</p> <p>Ax1 (Containment): Gamma &amp; Delta != empty. Ax2 (Base consequence): (Gamma, Delta) in |~_B exactly. Ax3 (Ontology schema consequence): matches a lazy ontology schema.</p> Source code in <code>pynmms/onto/base.py</code> <pre><code>def is_axiom(self, gamma: frozenset[str], delta: frozenset[str]) -&gt; bool:\n    \"\"\"Check if Gamma =&gt; Delta is an axiom.\n\n    Ax1 (Containment): Gamma &amp; Delta != empty.\n    Ax2 (Base consequence): (Gamma, Delta) in |~_B exactly.\n    Ax3 (Ontology schema consequence): matches a lazy ontology schema.\n    \"\"\"\n    # Ax1: Containment\n    if gamma &amp; delta:\n        return True\n    # Ax2: Explicit base consequence (exact match)\n    if (gamma, delta) in self._consequences:\n        return True\n    # Ax3: Ontology schema evaluation\n    if self._onto_schemas and self._check_onto_schemas(gamma, delta):\n        return True\n    return False\n</code></pre>"},{"location":"api/onto-base/#pynmms.onto.base.OntoMaterialBase.register_disjoint","title":"<code>register_disjoint(concept1, concept2, annotation=None)</code>","text":"<p>Register disjointWith schema: {C(x), D(x)} |~_B {} for any x.</p> <p>Material incompatibility between two concepts. Stored lazily.</p> Source code in <code>pynmms/onto/base.py</code> <pre><code>def register_disjoint(\n    self,\n    concept1: str,\n    concept2: str,\n    annotation: str | None = None,\n) -&gt; None:\n    \"\"\"Register disjointWith schema: {C(x), D(x)} |~_B {} for any x.\n\n    Material incompatibility between two concepts. Stored lazily.\n    \"\"\"\n    self._onto_schemas.append((\"disjointWith\", concept1, concept2, annotation))\n    logger.debug(\n        \"Registered disjointWith schema: %s \u22a5 %s\", concept1, concept2\n    )\n</code></pre>"},{"location":"api/onto-base/#pynmms.onto.base.OntoMaterialBase.register_disjoint_properties","title":"<code>register_disjoint_properties(role1, role2, annotation=None)</code>","text":"<p>Register disjointProperties schema: {R(x,y), S(x,y)} |~_B {} for any x, y.</p> <p>Material incompatibility between two roles. Stored lazily.</p> Source code in <code>pynmms/onto/base.py</code> <pre><code>def register_disjoint_properties(\n    self,\n    role1: str,\n    role2: str,\n    annotation: str | None = None,\n) -&gt; None:\n    \"\"\"Register disjointProperties schema: {R(x,y), S(x,y)} |~_B {} for any x, y.\n\n    Material incompatibility between two roles. Stored lazily.\n    \"\"\"\n    self._onto_schemas.append((\"disjointProperties\", role1, role2, annotation))\n    logger.debug(\n        \"Registered disjointProperties schema: %s \u22a5 %s\", role1, role2\n    )\n</code></pre>"},{"location":"api/onto-base/#pynmms.onto.base.OntoMaterialBase.register_domain","title":"<code>register_domain(role, concept, annotation=None)</code>","text":"<p>Register domain schema: {R(x,y)} |~ {C(x)} for any x, y.</p> <p>Stored lazily -- not grounded over known individuals.</p> Source code in <code>pynmms/onto/base.py</code> <pre><code>def register_domain(\n    self,\n    role: str,\n    concept: str,\n    annotation: str | None = None,\n) -&gt; None:\n    \"\"\"Register domain schema: {R(x,y)} |~ {C(x)} for any x, y.\n\n    Stored lazily -- not grounded over known individuals.\n    \"\"\"\n    self._onto_schemas.append((\"domain\", role, concept, annotation))\n    logger.debug(\"Registered domain schema: domain(%s) = %s\", role, concept)\n</code></pre>"},{"location":"api/onto-base/#pynmms.onto.base.OntoMaterialBase.register_range","title":"<code>register_range(role, concept, annotation=None)</code>","text":"<p>Register range schema: {R(x,y)} |~ {C(y)} for any x, y.</p> <p>Stored lazily -- not grounded over known individuals.</p> Source code in <code>pynmms/onto/base.py</code> <pre><code>def register_range(\n    self,\n    role: str,\n    concept: str,\n    annotation: str | None = None,\n) -&gt; None:\n    \"\"\"Register range schema: {R(x,y)} |~ {C(y)} for any x, y.\n\n    Stored lazily -- not grounded over known individuals.\n    \"\"\"\n    self._onto_schemas.append((\"range\", role, concept, annotation))\n    logger.debug(\"Registered range schema: range(%s) = %s\", role, concept)\n</code></pre>"},{"location":"api/onto-base/#pynmms.onto.base.OntoMaterialBase.register_subclass","title":"<code>register_subclass(sub_concept, super_concept, annotation=None)</code>","text":"<p>Register subClassOf schema: {sub(x)} |~ {super(x)} for any x.</p> <p>Stored lazily -- not grounded over known individuals.</p> Source code in <code>pynmms/onto/base.py</code> <pre><code>def register_subclass(\n    self,\n    sub_concept: str,\n    super_concept: str,\n    annotation: str | None = None,\n) -&gt; None:\n    \"\"\"Register subClassOf schema: {sub(x)} |~ {super(x)} for any x.\n\n    Stored lazily -- not grounded over known individuals.\n    \"\"\"\n    self._onto_schemas.append((\"subClassOf\", sub_concept, super_concept, annotation))\n    logger.debug(\n        \"Registered subClassOf schema: %s \u2291 %s\", sub_concept, super_concept\n    )\n</code></pre>"},{"location":"api/onto-base/#pynmms.onto.base.OntoMaterialBase.register_subproperty","title":"<code>register_subproperty(sub_role, super_role, annotation=None)</code>","text":"<p>Register subPropertyOf schema: {R(x,y)} |~ {S(x,y)} for any x, y.</p> <p>Stored lazily -- not grounded over known individuals.</p> Source code in <code>pynmms/onto/base.py</code> <pre><code>def register_subproperty(\n    self,\n    sub_role: str,\n    super_role: str,\n    annotation: str | None = None,\n) -&gt; None:\n    \"\"\"Register subPropertyOf schema: {R(x,y)} |~ {S(x,y)} for any x, y.\n\n    Stored lazily -- not grounded over known individuals.\n    \"\"\"\n    self._onto_schemas.append((\"subPropertyOf\", sub_role, super_role, annotation))\n    logger.debug(\n        \"Registered subPropertyOf schema: %s \u2291 %s\", sub_role, super_role\n    )\n</code></pre>"},{"location":"api/onto-base/#pynmms.onto.base.OntoMaterialBase.to_dict","title":"<code>to_dict()</code>","text":"<p>Serialize to a JSON-compatible dict, including ontology schemas.</p> Source code in <code>pynmms/onto/base.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Serialize to a JSON-compatible dict, including ontology schemas.\"\"\"\n    base_dict = super().to_dict()\n    base_dict[\"individuals\"] = sorted(self._individuals)\n    base_dict[\"concepts\"] = sorted(self._concepts)\n    base_dict[\"roles\"] = sorted(self._roles)\n    base_dict[\"onto_schemas\"] = [\n        {\n            \"type\": schema_type,\n            \"arg1\": arg1,\n            \"arg2\": arg2,\n            **({\"annotation\": annotation} if annotation else {}),\n        }\n        for schema_type, arg1, arg2, annotation in self._onto_schemas\n    ]\n    return base_dict\n</code></pre>"},{"location":"api/onto-base/#pynmms.onto.base.OntoMaterialBase.to_file","title":"<code>to_file(path)</code>","text":"<p>Write the base to a JSON file.</p> Source code in <code>pynmms/onto/base.py</code> <pre><code>def to_file(self, path: str | Path) -&gt; None:\n    \"\"\"Write the base to a JSON file.\"\"\"\n    with open(path, \"w\") as f:\n        json.dump(self.to_dict(), f, indent=2)\n    logger.debug(\"Saved ontology base to %s\", path)\n</code></pre>"},{"location":"api/onto-base/#pynmms.onto.base.CommitmentStore","title":"<code>CommitmentStore</code>","text":"<p>Manages ontology commitments and compiles them to an OntoMaterialBase.</p> <p>Higher-level API for managing assertions and ontology schemas, bridging natural language commitments to the atomic material base.</p> Source code in <code>pynmms/onto/base.py</code> <pre><code>class CommitmentStore:\n    \"\"\"Manages ontology commitments and compiles them to an OntoMaterialBase.\n\n    Higher-level API for managing assertions and ontology schemas, bridging\n    natural language commitments to the atomic material base.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self.assertions: set[str] = set()\n        self._onto_commitments: list[tuple[str, str, str, str]] = []\n        self._ground_rules: set[Sequent] = set()\n        self._base: OntoMaterialBase | None = None\n\n    def add_assertion(self, s: str) -&gt; None:\n        \"\"\"Add an atomic assertion.\"\"\"\n        _validate_onto_atomic(s, \"CommitmentStore.add_assertion\")\n        self.assertions.add(s)\n        self._base = None\n\n    def add_role(self, role: str, subject: str, obj: str) -&gt; None:\n        \"\"\"Add a role assertion R(subject, obj).\"\"\"\n        self.add_assertion(make_role_assertion(role, subject, obj))\n\n    def add_concept(self, concept: str, individual: str) -&gt; None:\n        \"\"\"Add a concept assertion C(individual).\"\"\"\n        self.add_assertion(make_concept_assertion(concept, individual))\n\n    def commit_subclass(\n        self,\n        source: str,\n        sub_concept: str,\n        super_concept: str,\n    ) -&gt; None:\n        \"\"\"Record a subClassOf commitment: {sub(x)} |~ {super(x)}.\"\"\"\n        self._onto_commitments.append((source, \"subClassOf\", sub_concept, super_concept))\n        self._base = None\n\n    def commit_range(\n        self,\n        source: str,\n        role: str,\n        concept: str,\n    ) -&gt; None:\n        \"\"\"Record a range commitment: {R(x,y)} |~ {C(y)}.\"\"\"\n        self._onto_commitments.append((source, \"range\", role, concept))\n        self._base = None\n\n    def commit_domain(\n        self,\n        source: str,\n        role: str,\n        concept: str,\n    ) -&gt; None:\n        \"\"\"Record a domain commitment: {R(x,y)} |~ {C(x)}.\"\"\"\n        self._onto_commitments.append((source, \"domain\", role, concept))\n        self._base = None\n\n    def commit_subproperty(\n        self,\n        source: str,\n        sub_role: str,\n        super_role: str,\n    ) -&gt; None:\n        \"\"\"Record a subPropertyOf commitment: {R(x,y)} |~ {S(x,y)}.\"\"\"\n        self._onto_commitments.append((source, \"subPropertyOf\", sub_role, super_role))\n        self._base = None\n\n    def commit_disjoint(\n        self,\n        source: str,\n        concept1: str,\n        concept2: str,\n    ) -&gt; None:\n        \"\"\"Record a disjointWith commitment: {C(x), D(x)} |~ {}.\"\"\"\n        self._onto_commitments.append((source, \"disjointWith\", concept1, concept2))\n        self._base = None\n\n    def commit_disjoint_properties(\n        self,\n        source: str,\n        role1: str,\n        role2: str,\n    ) -&gt; None:\n        \"\"\"Record a disjointProperties commitment: {R(x,y), S(x,y)} |~ {}.\"\"\"\n        self._onto_commitments.append((source, \"disjointProperties\", role1, role2))\n        self._base = None\n\n    def commit_defeasible_rule(\n        self,\n        source: str,\n        antecedent: frozenset[str],\n        consequent: frozenset[str],\n    ) -&gt; None:\n        \"\"\"Record a ground defeasible material inference.\"\"\"\n        for s in antecedent | consequent:\n            _validate_onto_atomic(s, f\"commit_defeasible_rule ({source})\")\n            self.assertions.add(s)\n        self._ground_rules.add((antecedent, consequent))\n        self._base = None\n\n    def retract_schema(self, source: str) -&gt; None:\n        \"\"\"Retract all schemas with the given source.\"\"\"\n        self._onto_commitments = [\n            c for c in self._onto_commitments if c[0] != source\n        ]\n        self._base = None\n\n    def compile(self) -&gt; OntoMaterialBase:\n        \"\"\"Compile current commitments into an OntoMaterialBase.\n\n        Schemas are registered lazily -- no eager grounding.\n        \"\"\"\n        if self._base is not None:\n            return self._base\n\n        language = set(self.assertions)\n        consequences: set[Sequent] = set(self._ground_rules)\n\n        self._base = OntoMaterialBase(\n            language=language,\n            consequences=consequences,\n        )\n\n        # Register ontology schemas lazily\n        for _source, schema_type, arg1, arg2 in self._onto_commitments:\n            if schema_type == \"subClassOf\":\n                self._base.register_subclass(arg1, arg2)\n            elif schema_type == \"range\":\n                self._base.register_range(arg1, arg2)\n            elif schema_type == \"domain\":\n                self._base.register_domain(arg1, arg2)\n            elif schema_type == \"subPropertyOf\":\n                self._base.register_subproperty(arg1, arg2)\n            elif schema_type == \"disjointWith\":\n                self._base.register_disjoint(arg1, arg2)\n            elif schema_type == \"disjointProperties\":\n                self._base.register_disjoint_properties(arg1, arg2)\n\n        return self._base\n\n    def describe(self) -&gt; str:\n        \"\"\"Human-readable description of current commitments.\"\"\"\n        lines = [\"Commitment Store:\"]\n        lines.append(f\"  Assertions: {len(self.assertions)}\")\n        for s in sorted(self.assertions):\n            lines.append(f\"    {s}\")\n        lines.append(f\"  Ontology Schemas: {len(self._onto_commitments)}\")\n        for source, schema_type, arg1, arg2 in self._onto_commitments:\n            if schema_type == \"subClassOf\":\n                pattern = f\"{arg1}(x) |~ {arg2}(x)\"\n            elif schema_type == \"range\":\n                pattern = f\"{arg1}(x,y) |~ {arg2}(y)\"\n            elif schema_type == \"domain\":\n                pattern = f\"{arg1}(x,y) |~ {arg2}(x)\"\n            elif schema_type == \"subPropertyOf\":\n                pattern = f\"{arg1}(x,y) |~ {arg2}(x,y)\"\n            elif schema_type == \"disjointWith\":\n                pattern = f\"{arg1}(x), {arg2}(x) |~\"\n            elif schema_type == \"disjointProperties\":\n                pattern = f\"{arg1}(x,y), {arg2}(x,y) |~\"\n            else:\n                pattern = f\"{arg1} -&gt; {arg2}\"  # pragma: no cover\n            lines.append(f\"    [{source}] {schema_type}: {pattern}\")\n        if self._ground_rules:\n            lines.append(f\"  Ground rules: {len(self._ground_rules)}\")\n            for ant, con in self._ground_rules:\n                lines.append(f\"    {set(ant)} |~ {set(con)}\")\n        return \"\\n\".join(lines)\n</code></pre>"},{"location":"api/onto-base/#pynmms.onto.base.CommitmentStore.add_assertion","title":"<code>add_assertion(s)</code>","text":"<p>Add an atomic assertion.</p> Source code in <code>pynmms/onto/base.py</code> <pre><code>def add_assertion(self, s: str) -&gt; None:\n    \"\"\"Add an atomic assertion.\"\"\"\n    _validate_onto_atomic(s, \"CommitmentStore.add_assertion\")\n    self.assertions.add(s)\n    self._base = None\n</code></pre>"},{"location":"api/onto-base/#pynmms.onto.base.CommitmentStore.add_concept","title":"<code>add_concept(concept, individual)</code>","text":"<p>Add a concept assertion C(individual).</p> Source code in <code>pynmms/onto/base.py</code> <pre><code>def add_concept(self, concept: str, individual: str) -&gt; None:\n    \"\"\"Add a concept assertion C(individual).\"\"\"\n    self.add_assertion(make_concept_assertion(concept, individual))\n</code></pre>"},{"location":"api/onto-base/#pynmms.onto.base.CommitmentStore.add_role","title":"<code>add_role(role, subject, obj)</code>","text":"<p>Add a role assertion R(subject, obj).</p> Source code in <code>pynmms/onto/base.py</code> <pre><code>def add_role(self, role: str, subject: str, obj: str) -&gt; None:\n    \"\"\"Add a role assertion R(subject, obj).\"\"\"\n    self.add_assertion(make_role_assertion(role, subject, obj))\n</code></pre>"},{"location":"api/onto-base/#pynmms.onto.base.CommitmentStore.commit_defeasible_rule","title":"<code>commit_defeasible_rule(source, antecedent, consequent)</code>","text":"<p>Record a ground defeasible material inference.</p> Source code in <code>pynmms/onto/base.py</code> <pre><code>def commit_defeasible_rule(\n    self,\n    source: str,\n    antecedent: frozenset[str],\n    consequent: frozenset[str],\n) -&gt; None:\n    \"\"\"Record a ground defeasible material inference.\"\"\"\n    for s in antecedent | consequent:\n        _validate_onto_atomic(s, f\"commit_defeasible_rule ({source})\")\n        self.assertions.add(s)\n    self._ground_rules.add((antecedent, consequent))\n    self._base = None\n</code></pre>"},{"location":"api/onto-base/#pynmms.onto.base.CommitmentStore.commit_disjoint","title":"<code>commit_disjoint(source, concept1, concept2)</code>","text":"<p>Record a disjointWith commitment: {C(x), D(x)} |~ {}.</p> Source code in <code>pynmms/onto/base.py</code> <pre><code>def commit_disjoint(\n    self,\n    source: str,\n    concept1: str,\n    concept2: str,\n) -&gt; None:\n    \"\"\"Record a disjointWith commitment: {C(x), D(x)} |~ {}.\"\"\"\n    self._onto_commitments.append((source, \"disjointWith\", concept1, concept2))\n    self._base = None\n</code></pre>"},{"location":"api/onto-base/#pynmms.onto.base.CommitmentStore.commit_disjoint_properties","title":"<code>commit_disjoint_properties(source, role1, role2)</code>","text":"<p>Record a disjointProperties commitment: {R(x,y), S(x,y)} |~ {}.</p> Source code in <code>pynmms/onto/base.py</code> <pre><code>def commit_disjoint_properties(\n    self,\n    source: str,\n    role1: str,\n    role2: str,\n) -&gt; None:\n    \"\"\"Record a disjointProperties commitment: {R(x,y), S(x,y)} |~ {}.\"\"\"\n    self._onto_commitments.append((source, \"disjointProperties\", role1, role2))\n    self._base = None\n</code></pre>"},{"location":"api/onto-base/#pynmms.onto.base.CommitmentStore.commit_domain","title":"<code>commit_domain(source, role, concept)</code>","text":"<p>Record a domain commitment: {R(x,y)} |~ {C(x)}.</p> Source code in <code>pynmms/onto/base.py</code> <pre><code>def commit_domain(\n    self,\n    source: str,\n    role: str,\n    concept: str,\n) -&gt; None:\n    \"\"\"Record a domain commitment: {R(x,y)} |~ {C(x)}.\"\"\"\n    self._onto_commitments.append((source, \"domain\", role, concept))\n    self._base = None\n</code></pre>"},{"location":"api/onto-base/#pynmms.onto.base.CommitmentStore.commit_range","title":"<code>commit_range(source, role, concept)</code>","text":"<p>Record a range commitment: {R(x,y)} |~ {C(y)}.</p> Source code in <code>pynmms/onto/base.py</code> <pre><code>def commit_range(\n    self,\n    source: str,\n    role: str,\n    concept: str,\n) -&gt; None:\n    \"\"\"Record a range commitment: {R(x,y)} |~ {C(y)}.\"\"\"\n    self._onto_commitments.append((source, \"range\", role, concept))\n    self._base = None\n</code></pre>"},{"location":"api/onto-base/#pynmms.onto.base.CommitmentStore.commit_subclass","title":"<code>commit_subclass(source, sub_concept, super_concept)</code>","text":"<p>Record a subClassOf commitment: {sub(x)} |~ {super(x)}.</p> Source code in <code>pynmms/onto/base.py</code> <pre><code>def commit_subclass(\n    self,\n    source: str,\n    sub_concept: str,\n    super_concept: str,\n) -&gt; None:\n    \"\"\"Record a subClassOf commitment: {sub(x)} |~ {super(x)}.\"\"\"\n    self._onto_commitments.append((source, \"subClassOf\", sub_concept, super_concept))\n    self._base = None\n</code></pre>"},{"location":"api/onto-base/#pynmms.onto.base.CommitmentStore.commit_subproperty","title":"<code>commit_subproperty(source, sub_role, super_role)</code>","text":"<p>Record a subPropertyOf commitment: {R(x,y)} |~ {S(x,y)}.</p> Source code in <code>pynmms/onto/base.py</code> <pre><code>def commit_subproperty(\n    self,\n    source: str,\n    sub_role: str,\n    super_role: str,\n) -&gt; None:\n    \"\"\"Record a subPropertyOf commitment: {R(x,y)} |~ {S(x,y)}.\"\"\"\n    self._onto_commitments.append((source, \"subPropertyOf\", sub_role, super_role))\n    self._base = None\n</code></pre>"},{"location":"api/onto-base/#pynmms.onto.base.CommitmentStore.compile","title":"<code>compile()</code>","text":"<p>Compile current commitments into an OntoMaterialBase.</p> <p>Schemas are registered lazily -- no eager grounding.</p> Source code in <code>pynmms/onto/base.py</code> <pre><code>def compile(self) -&gt; OntoMaterialBase:\n    \"\"\"Compile current commitments into an OntoMaterialBase.\n\n    Schemas are registered lazily -- no eager grounding.\n    \"\"\"\n    if self._base is not None:\n        return self._base\n\n    language = set(self.assertions)\n    consequences: set[Sequent] = set(self._ground_rules)\n\n    self._base = OntoMaterialBase(\n        language=language,\n        consequences=consequences,\n    )\n\n    # Register ontology schemas lazily\n    for _source, schema_type, arg1, arg2 in self._onto_commitments:\n        if schema_type == \"subClassOf\":\n            self._base.register_subclass(arg1, arg2)\n        elif schema_type == \"range\":\n            self._base.register_range(arg1, arg2)\n        elif schema_type == \"domain\":\n            self._base.register_domain(arg1, arg2)\n        elif schema_type == \"subPropertyOf\":\n            self._base.register_subproperty(arg1, arg2)\n        elif schema_type == \"disjointWith\":\n            self._base.register_disjoint(arg1, arg2)\n        elif schema_type == \"disjointProperties\":\n            self._base.register_disjoint_properties(arg1, arg2)\n\n    return self._base\n</code></pre>"},{"location":"api/onto-base/#pynmms.onto.base.CommitmentStore.describe","title":"<code>describe()</code>","text":"<p>Human-readable description of current commitments.</p> Source code in <code>pynmms/onto/base.py</code> <pre><code>def describe(self) -&gt; str:\n    \"\"\"Human-readable description of current commitments.\"\"\"\n    lines = [\"Commitment Store:\"]\n    lines.append(f\"  Assertions: {len(self.assertions)}\")\n    for s in sorted(self.assertions):\n        lines.append(f\"    {s}\")\n    lines.append(f\"  Ontology Schemas: {len(self._onto_commitments)}\")\n    for source, schema_type, arg1, arg2 in self._onto_commitments:\n        if schema_type == \"subClassOf\":\n            pattern = f\"{arg1}(x) |~ {arg2}(x)\"\n        elif schema_type == \"range\":\n            pattern = f\"{arg1}(x,y) |~ {arg2}(y)\"\n        elif schema_type == \"domain\":\n            pattern = f\"{arg1}(x,y) |~ {arg2}(x)\"\n        elif schema_type == \"subPropertyOf\":\n            pattern = f\"{arg1}(x,y) |~ {arg2}(x,y)\"\n        elif schema_type == \"disjointWith\":\n            pattern = f\"{arg1}(x), {arg2}(x) |~\"\n        elif schema_type == \"disjointProperties\":\n            pattern = f\"{arg1}(x,y), {arg2}(x,y) |~\"\n        else:\n            pattern = f\"{arg1} -&gt; {arg2}\"  # pragma: no cover\n        lines.append(f\"    [{source}] {schema_type}: {pattern}\")\n    if self._ground_rules:\n        lines.append(f\"  Ground rules: {len(self._ground_rules)}\")\n        for ant, con in self._ground_rules:\n            lines.append(f\"    {set(ant)} |~ {set(con)}\")\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"api/onto-base/#pynmms.onto.base.CommitmentStore.retract_schema","title":"<code>retract_schema(source)</code>","text":"<p>Retract all schemas with the given source.</p> Source code in <code>pynmms/onto/base.py</code> <pre><code>def retract_schema(self, source: str) -&gt; None:\n    \"\"\"Retract all schemas with the given source.\"\"\"\n    self._onto_commitments = [\n        c for c in self._onto_commitments if c[0] != source\n    ]\n    self._base = None\n</code></pre>"},{"location":"api/onto-syntax/","title":"Ontology Syntax","text":""},{"location":"api/onto-syntax/#pynmms.onto.syntax","title":"<code>pynmms.onto.syntax</code>","text":"<p>Ontology-style concept/role assertion parsing for NMMS.</p> <p>Extends the propositional parser with concept assertions (<code>C(a)</code>) and role assertions (<code>R(a,b)</code>) for ontology-style reasoning.</p> <p>Grammar additions (beyond propositional)::</p> <pre><code>concept_atom  ::= CONCEPT '(' INDIVIDUAL ')'\nrole_atom     ::= ROLE '(' INDIVIDUAL ',' INDIVIDUAL ')'\n</code></pre> <p>The parser tries binary connectives first (at depth-0), then ontology-specific patterns (role assertions, concept assertions). Bare propositional atoms are rejected -- use concept assertions <code>C(a)</code> or role assertions <code>R(a,b)</code> instead.</p>"},{"location":"api/onto-syntax/#pynmms.onto.syntax.OntoSentence","title":"<code>OntoSentence</code>  <code>dataclass</code>","text":"<p>Immutable AST node for an ontology-style sentence.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>str</code> <p>One of ATOM_CONCEPT, ATOM_ROLE.</p> <code>concept</code> <code>str | None</code> <p>Concept name (for concept assertions).</p> <code>individual</code> <code>str | None</code> <p>Individual name (for concept assertions).</p> <code>role</code> <code>str | None</code> <p>Role name (for role assertions).</p> <code>arg1</code> <code>str | None</code> <p>First argument of role assertion.</p> <code>arg2</code> <code>str | None</code> <p>Second argument of role assertion.</p> Source code in <code>pynmms/onto/syntax.py</code> <pre><code>@dataclass(frozen=True, slots=True)\nclass OntoSentence:\n    \"\"\"Immutable AST node for an ontology-style sentence.\n\n    Attributes:\n        type: One of ATOM_CONCEPT, ATOM_ROLE.\n        concept: Concept name (for concept assertions).\n        individual: Individual name (for concept assertions).\n        role: Role name (for role assertions).\n        arg1: First argument of role assertion.\n        arg2: Second argument of role assertion.\n    \"\"\"\n\n    type: str\n    concept: str | None = None\n    individual: str | None = None\n    role: str | None = None\n    arg1: str | None = None\n    arg2: str | None = None\n\n    def __str__(self) -&gt; str:\n        if self.type == ATOM_CONCEPT:\n            return f\"{self.concept}({self.individual})\"\n        if self.type == ATOM_ROLE:\n            return f\"{self.role}({self.arg1},{self.arg2})\"\n        return f\"OntoSentence({self.type})\"  # pragma: no cover\n</code></pre>"},{"location":"api/onto-syntax/#pynmms.onto.syntax.parse_onto_sentence","title":"<code>parse_onto_sentence(s)</code>","text":"<p>Parse a string into a propositional Sentence or OntoSentence AST.</p> <p>Tries binary connectives first (at depth-0), then ontology-specific patterns (role assertions, concept assertions), then falls through to propositional negation.</p> Source code in <code>pynmms/onto/syntax.py</code> <pre><code>def parse_onto_sentence(s: str) -&gt; Sentence | OntoSentence:\n    \"\"\"Parse a string into a propositional Sentence or OntoSentence AST.\n\n    Tries binary connectives first (at depth-0), then ontology-specific patterns\n    (role assertions, concept assertions), then falls through to propositional\n    negation.\n    \"\"\"\n    s = s.strip()\n    if not s:\n        raise ValueError(\"Cannot parse empty sentence\")\n\n    # Strip outer parens if they wrap the entire expression\n    if s.startswith(\"(\") and s.endswith(\")\"):\n        depth = 0\n        all_wrapped = True\n        for i, c in enumerate(s):\n            if c == \"(\":\n                depth += 1\n            elif c == \")\":\n                depth -= 1\n            if depth == 0 and i &lt; len(s) - 1:\n                all_wrapped = False\n                break\n        if all_wrapped:\n            return parse_onto_sentence(s[1:-1])\n\n    # --- Binary connectives at depth 0, lowest precedence first ---\n\n    # Implication (right-associative, lowest precedence)\n    depth = 0\n    for i in range(len(s)):\n        c = s[i]\n        if c == \"(\":\n            depth += 1\n        elif c == \")\":\n            depth -= 1\n        elif depth == 0 and s[i : i + 2] == \"-&gt;\":\n            left_str = s[:i].strip()\n            right_str = s[i + 2 :].strip()\n            if not left_str or not right_str:\n                raise ValueError(f\"Malformed implication in: {s!r}\")\n            return Sentence(\n                type=IMPL,\n                left=parse_sentence(left_str),\n                right=parse_sentence(right_str),\n            )\n\n    # Disjunction (left-associative) -- find last '|' at depth 0\n    depth = 0\n    last_disj = -1\n    for i, c in enumerate(s):\n        if c == \"(\":\n            depth += 1\n        elif c == \")\":\n            depth -= 1\n        elif depth == 0 and c == \"|\":\n            last_disj = i\n    if last_disj &gt;= 0:\n        left_str = s[:last_disj].strip()\n        right_str = s[last_disj + 1 :].strip()\n        if not left_str or not right_str:\n            raise ValueError(f\"Malformed disjunction in: {s!r}\")\n        return Sentence(\n            type=DISJ,\n            left=parse_sentence(left_str),\n            right=parse_sentence(right_str),\n        )\n\n    # Conjunction (left-associative) -- find last '&amp;' at depth 0\n    depth = 0\n    last_conj = -1\n    for i, c in enumerate(s):\n        if c == \"(\":\n            depth += 1\n        elif c == \")\":\n            depth -= 1\n        elif depth == 0 and c == \"&amp;\":\n            last_conj = i\n    if last_conj &gt;= 0:\n        left_str = s[:last_conj].strip()\n        right_str = s[last_conj + 1 :].strip()\n        if not left_str or not right_str:\n            raise ValueError(f\"Malformed conjunction in: {s!r}\")\n        return Sentence(\n            type=CONJ,\n            left=parse_sentence(left_str),\n            right=parse_sentence(right_str),\n        )\n\n    # Negation\n    if s.startswith(\"~\"):\n        sub_str = s[1:].strip()\n        if not sub_str:\n            raise ValueError(\"Negation with no operand\")\n        return Sentence(type=NEG, sub=parse_sentence(sub_str))\n\n    # --- Ontology-specific atomic patterns ---\n\n    # Role assertion: R(a,b)\n    m = _ROLE_RE.match(s)\n    if m:\n        return OntoSentence(\n            type=ATOM_ROLE,\n            role=m.group(1),\n            arg1=m.group(2),\n            arg2=m.group(3),\n        )\n\n    # Concept assertion: C(a)\n    m = _CONCEPT_RE.match(s)\n    if m:\n        return OntoSentence(\n            type=ATOM_CONCEPT,\n            concept=m.group(1),\n            individual=m.group(2),\n        )\n\n    # Bare propositional atoms are not valid in NMMS_Onto.\n    raise ValueError(\n        f\"Bare atom {s!r} is not valid in NMMS_Onto. \"\n        f\"Use concept assertions C(a) or role assertions R(a,b).\"\n    )\n</code></pre>"},{"location":"api/onto-syntax/#pynmms.onto.syntax.is_onto_atomic","title":"<code>is_onto_atomic(s)</code>","text":"<p>Return True if s is a concept assertion or role assertion.</p> Source code in <code>pynmms/onto/syntax.py</code> <pre><code>def is_onto_atomic(s: str) -&gt; bool:\n    \"\"\"Return True if *s* is a concept assertion or role assertion.\"\"\"\n    try:\n        parsed = parse_onto_sentence(s)\n    except ValueError:\n        return False\n    if isinstance(parsed, OntoSentence):\n        return parsed.type in (ATOM_CONCEPT, ATOM_ROLE)\n    return False\n</code></pre>"},{"location":"api/onto-syntax/#pynmms.onto.syntax.all_onto_atomic","title":"<code>all_onto_atomic(sentences)</code>","text":"<p>Return True if every sentence in sentences is onto-atomic.</p> Source code in <code>pynmms/onto/syntax.py</code> <pre><code>def all_onto_atomic(sentences: frozenset[str]) -&gt; bool:\n    \"\"\"Return True if every sentence in *sentences* is onto-atomic.\"\"\"\n    return all(is_onto_atomic(s) for s in sentences)\n</code></pre>"},{"location":"api/onto-syntax/#pynmms.onto.syntax.make_concept_assertion","title":"<code>make_concept_assertion(concept, individual)</code>","text":"<p>Construct <code>C(a)</code> string.</p> Source code in <code>pynmms/onto/syntax.py</code> <pre><code>def make_concept_assertion(concept: str, individual: str) -&gt; str:\n    \"\"\"Construct ``C(a)`` string.\"\"\"\n    return f\"{concept}({individual})\"\n</code></pre>"},{"location":"api/onto-syntax/#pynmms.onto.syntax.make_role_assertion","title":"<code>make_role_assertion(role, arg1, arg2)</code>","text":"<p>Construct <code>R(a,b)</code> string.</p> Source code in <code>pynmms/onto/syntax.py</code> <pre><code>def make_role_assertion(role: str, arg1: str, arg2: str) -&gt; str:\n    \"\"\"Construct ``R(a,b)`` string.\"\"\"\n    return f\"{role}({arg1},{arg2})\"\n</code></pre>"},{"location":"api/reasoner/","title":"NMMSReasoner","text":""},{"location":"api/reasoner/#pynmms.reasoner.NMMSReasoner","title":"<code>pynmms.reasoner.NMMSReasoner</code>","text":"<p>Proof search for propositional NMMS sequent calculus.</p> <p>Performs backward (root-first) proof search with memoization and depth-limited search. A sequent Gamma =&gt; Delta is derivable iff all leaves of its proof tree are axioms of the material base.</p> <p>Parameters:</p> Name Type Description Default <code>base</code> <code>MaterialBase</code> <p>The material base providing axioms.</p> required <code>max_depth</code> <code>int</code> <p>Maximum proof depth (default 25).</p> <code>25</code> Source code in <code>pynmms/reasoner.py</code> <pre><code>class NMMSReasoner:\n    \"\"\"Proof search for propositional NMMS sequent calculus.\n\n    Performs backward (root-first) proof search with memoization and\n    depth-limited search. A sequent Gamma =&gt; Delta is derivable iff\n    all leaves of its proof tree are axioms of the material base.\n\n    Parameters:\n        base: The material base providing axioms.\n        max_depth: Maximum proof depth (default 25).\n    \"\"\"\n\n    def __init__(self, base: MaterialBase, *, max_depth: int = 25) -&gt; None:\n        self.base = base\n        self.max_depth = max_depth\n        self._trace: list[str] = []\n        self._cache: dict[tuple[frozenset[str], frozenset[str]], bool] = {}\n        self._depth_reached: int = 0\n        self._cache_hits: int = 0\n\n    def derives(self, antecedent: frozenset[str], consequent: frozenset[str]) -&gt; ProofResult:\n        \"\"\"Check if ``antecedent =&gt; consequent`` is derivable in NMMS_B.\n\n        Returns a ``ProofResult`` with derivability, proof trace, and statistics.\n        \"\"\"\n        self._trace = []\n        self._cache = {}\n        self._depth_reached = 0\n        self._cache_hits = 0\n\n        logger.debug(\"Proof search: %s =&gt; %s\", _fmt(antecedent), _fmt(consequent))\n        result = self._prove(antecedent, consequent, depth=0)\n        logger.debug(\"Result: %s (depth %d, cache hits %d)\",\n                      result, self._depth_reached, self._cache_hits)\n\n        return ProofResult(\n            derivable=result,\n            trace=list(self._trace),\n            depth_reached=self._depth_reached,\n            cache_hits=self._cache_hits,\n        )\n\n    def query(self, antecedent: frozenset[str], consequent: frozenset[str]) -&gt; bool:\n        \"\"\"Convenience method: return only the derivability boolean.\"\"\"\n        return self.derives(antecedent, consequent).derivable\n\n    # ------------------------------------------------------------------\n    # Internal proof search\n    # ------------------------------------------------------------------\n\n    def _prove(self, gamma: frozenset[str], delta: frozenset[str], depth: int) -&gt; bool:\n        \"\"\"Backward proof search with memoization.\"\"\"\n        indent = \"  \" * depth\n        self._depth_reached = max(self._depth_reached, depth)\n\n        if depth &gt; self.max_depth:\n            msg = f\"{indent}DEPTH LIMIT\"\n            self._trace.append(msg)\n            logger.debug(msg)\n            return False\n\n        # Memoization\n        key = (gamma, delta)\n        if key in self._cache:\n            self._cache_hits += 1\n            return self._cache[key]\n\n        # Check axiom\n        if self.base.is_axiom(gamma, delta):\n            msg = f\"{indent}AXIOM: {_fmt(gamma)} =&gt; {_fmt(delta)}\"\n            self._trace.append(msg)\n            logger.debug(msg)\n            self._cache[key] = True\n            return True\n\n        # Mark as False initially to detect cycles\n        self._cache[key] = False\n\n        result = self._try_left_rules(gamma, delta, depth) or self._try_right_rules(\n            gamma, delta, depth\n        )\n\n        self._cache[key] = result\n        if not result:\n            msg = f\"{indent}FAIL: {_fmt(gamma)} =&gt; {_fmt(delta)}\"\n            self._trace.append(msg)\n            logger.debug(msg)\n        return result\n\n    # ------------------------------------------------------------------\n    # LEFT RULES\n    # ------------------------------------------------------------------\n\n    def _try_left_rules(\n        self, gamma: frozenset[str], delta: frozenset[str], depth: int\n    ) -&gt; bool:\n        indent = \"  \" * depth\n\n        for s in sorted(gamma):  # sorted for determinism\n            parsed = parse_sentence(s)\n            rest = gamma - {s}\n\n            # [L~]: Gamma, ~A =&gt; Delta  &lt;-  Gamma =&gt; Delta, A\n            if parsed.type == NEG:\n                assert parsed.sub is not None\n                a = str(parsed.sub)\n                msg = f\"{indent}[L\\u00ac] on {s}\"\n                self._trace.append(msg)\n                logger.debug(msg)\n                if self._prove(rest, delta | {a}, depth + 1):\n                    return True\n\n            # [L-&gt;]: Gamma, A-&gt;B =&gt; Delta  &lt;-  (1) Gamma =&gt; Delta, A\n            #                                   (2) Gamma, B =&gt; Delta\n            #                                   (3) Gamma, B =&gt; Delta, A\n            elif parsed.type == IMPL:\n                assert parsed.left is not None and parsed.right is not None\n                a, b = str(parsed.left), str(parsed.right)\n                msg = f\"{indent}[L\\u2192] on {s}\"\n                self._trace.append(msg)\n                logger.debug(msg)\n                if (\n                    self._prove(rest, delta | {a}, depth + 1)\n                    and self._prove(rest | {b}, delta, depth + 1)\n                    and self._prove(rest | {b}, delta | {a}, depth + 1)\n                ):\n                    return True\n\n            # [L&amp;]: Gamma, A &amp; B =&gt; Delta  &lt;-  Gamma, A, B =&gt; Delta\n            elif parsed.type == CONJ:\n                assert parsed.left is not None and parsed.right is not None\n                a, b = str(parsed.left), str(parsed.right)\n                msg = f\"{indent}[L\\u2227] on {s}\"\n                self._trace.append(msg)\n                logger.debug(msg)\n                if self._prove(rest | {a, b}, delta, depth + 1):\n                    return True\n\n            # [L|]: Gamma, A | B =&gt; Delta  &lt;-  (1) Gamma, A =&gt; Delta\n            #                                   (2) Gamma, B =&gt; Delta\n            #                                   (3) Gamma, A, B =&gt; Delta\n            elif parsed.type == DISJ:\n                assert parsed.left is not None and parsed.right is not None\n                a, b = str(parsed.left), str(parsed.right)\n                msg = f\"{indent}[L\\u2228] on {s}\"\n                self._trace.append(msg)\n                logger.debug(msg)\n                if (\n                    self._prove(rest | {a}, delta, depth + 1)\n                    and self._prove(rest | {b}, delta, depth + 1)\n                    and self._prove(rest | {a, b}, delta, depth + 1)\n                ):\n                    return True\n\n        return False\n\n    # ------------------------------------------------------------------\n    # RIGHT RULES\n    # ------------------------------------------------------------------\n\n    def _try_right_rules(\n        self, gamma: frozenset[str], delta: frozenset[str], depth: int\n    ) -&gt; bool:\n        indent = \"  \" * depth\n\n        for s in sorted(delta):\n            parsed = parse_sentence(s)\n            rest = delta - {s}\n\n            # [R~]: Gamma =&gt; Delta, ~A  &lt;-  Gamma, A =&gt; Delta\n            if parsed.type == NEG:\n                assert parsed.sub is not None\n                a = str(parsed.sub)\n                msg = f\"{indent}[R\\u00ac] on {s}\"\n                self._trace.append(msg)\n                logger.debug(msg)\n                if self._prove(gamma | {a}, rest, depth + 1):\n                    return True\n\n            # [R-&gt;]: Gamma =&gt; Delta, A-&gt;B  &lt;-  Gamma, A =&gt; Delta, B\n            elif parsed.type == IMPL:\n                assert parsed.left is not None and parsed.right is not None\n                a, b = str(parsed.left), str(parsed.right)\n                msg = f\"{indent}[R\\u2192] on {s}\"\n                self._trace.append(msg)\n                logger.debug(msg)\n                if self._prove(gamma | {a}, rest | {b}, depth + 1):\n                    return True\n\n            # [R&amp;]: Gamma =&gt; Delta, A &amp; B  &lt;-  (1) Gamma =&gt; Delta, A\n            #                                   (2) Gamma =&gt; Delta, B\n            #                                   (3) Gamma =&gt; Delta, A, B\n            elif parsed.type == CONJ:\n                assert parsed.left is not None and parsed.right is not None\n                a, b = str(parsed.left), str(parsed.right)\n                msg = f\"{indent}[R\\u2227] on {s}\"\n                self._trace.append(msg)\n                logger.debug(msg)\n                if (\n                    self._prove(gamma, rest | {a}, depth + 1)\n                    and self._prove(gamma, rest | {b}, depth + 1)\n                    and self._prove(gamma, rest | {a, b}, depth + 1)\n                ):\n                    return True\n\n            # [R|]: Gamma =&gt; Delta, A | B  &lt;-  Gamma =&gt; Delta, A, B\n            elif parsed.type == DISJ:\n                assert parsed.left is not None and parsed.right is not None\n                a, b = str(parsed.left), str(parsed.right)\n                msg = f\"{indent}[R\\u2228] on {s}\"\n                self._trace.append(msg)\n                logger.debug(msg)\n                if self._prove(gamma, rest | {a, b}, depth + 1):\n                    return True\n\n        return False\n</code></pre>"},{"location":"api/reasoner/#pynmms.reasoner.NMMSReasoner.__init__","title":"<code>__init__(base, *, max_depth=25)</code>","text":"Source code in <code>pynmms/reasoner.py</code> <pre><code>def __init__(self, base: MaterialBase, *, max_depth: int = 25) -&gt; None:\n    self.base = base\n    self.max_depth = max_depth\n    self._trace: list[str] = []\n    self._cache: dict[tuple[frozenset[str], frozenset[str]], bool] = {}\n    self._depth_reached: int = 0\n    self._cache_hits: int = 0\n</code></pre>"},{"location":"api/reasoner/#pynmms.reasoner.NMMSReasoner.derives","title":"<code>derives(antecedent, consequent)</code>","text":"<p>Check if <code>antecedent =&gt; consequent</code> is derivable in NMMS_B.</p> <p>Returns a <code>ProofResult</code> with derivability, proof trace, and statistics.</p> Source code in <code>pynmms/reasoner.py</code> <pre><code>def derives(self, antecedent: frozenset[str], consequent: frozenset[str]) -&gt; ProofResult:\n    \"\"\"Check if ``antecedent =&gt; consequent`` is derivable in NMMS_B.\n\n    Returns a ``ProofResult`` with derivability, proof trace, and statistics.\n    \"\"\"\n    self._trace = []\n    self._cache = {}\n    self._depth_reached = 0\n    self._cache_hits = 0\n\n    logger.debug(\"Proof search: %s =&gt; %s\", _fmt(antecedent), _fmt(consequent))\n    result = self._prove(antecedent, consequent, depth=0)\n    logger.debug(\"Result: %s (depth %d, cache hits %d)\",\n                  result, self._depth_reached, self._cache_hits)\n\n    return ProofResult(\n        derivable=result,\n        trace=list(self._trace),\n        depth_reached=self._depth_reached,\n        cache_hits=self._cache_hits,\n    )\n</code></pre>"},{"location":"api/reasoner/#pynmms.reasoner.NMMSReasoner.query","title":"<code>query(antecedent, consequent)</code>","text":"<p>Convenience method: return only the derivability boolean.</p> Source code in <code>pynmms/reasoner.py</code> <pre><code>def query(self, antecedent: frozenset[str], consequent: frozenset[str]) -&gt; bool:\n    \"\"\"Convenience method: return only the derivability boolean.\"\"\"\n    return self.derives(antecedent, consequent).derivable\n</code></pre>"},{"location":"api/reasoner/#pynmms.reasoner.ProofResult","title":"<code>pynmms.reasoner.ProofResult</code>  <code>dataclass</code>","text":"<p>Result of a proof search.</p> <p>Attributes:</p> Name Type Description <code>derivable</code> <code>bool</code> <p>Whether the sequent is derivable.</p> <code>trace</code> <code>list[str]</code> <p>Human-readable proof trace.</p> <code>depth_reached</code> <code>int</code> <p>Maximum proof depth reached.</p> <code>cache_hits</code> <code>int</code> <p>Number of memoization cache hits.</p> Source code in <code>pynmms/reasoner.py</code> <pre><code>@dataclass\nclass ProofResult:\n    \"\"\"Result of a proof search.\n\n    Attributes:\n        derivable: Whether the sequent is derivable.\n        trace: Human-readable proof trace.\n        depth_reached: Maximum proof depth reached.\n        cache_hits: Number of memoization cache hits.\n    \"\"\"\n\n    derivable: bool\n    trace: list[str] = field(default_factory=list)\n    depth_reached: int = 0\n    cache_hits: int = 0\n</code></pre>"},{"location":"api/syntax/","title":"Syntax","text":""},{"location":"api/syntax/#pynmms.syntax.Sentence","title":"<code>pynmms.syntax.Sentence</code>  <code>dataclass</code>","text":"<p>Immutable AST node for a propositional sentence.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>str</code> <p>One of ATOM, NEG, CONJ, DISJ, IMPL.</p> <code>name</code> <code>str | None</code> <p>The atom name (only when type == ATOM).</p> <code>sub</code> <code>Sentence | None</code> <p>The sub-sentence (only when type == NEG).</p> <code>left</code> <code>Sentence | None</code> <p>Left operand (only when type in {CONJ, DISJ, IMPL}).</p> <code>right</code> <code>Sentence | None</code> <p>Right operand (only when type in {CONJ, DISJ, IMPL}).</p> Source code in <code>pynmms/syntax.py</code> <pre><code>@dataclass(frozen=True, slots=True)\nclass Sentence:\n    \"\"\"Immutable AST node for a propositional sentence.\n\n    Attributes:\n        type: One of ATOM, NEG, CONJ, DISJ, IMPL.\n        name: The atom name (only when type == ATOM).\n        sub: The sub-sentence (only when type == NEG).\n        left: Left operand (only when type in {CONJ, DISJ, IMPL}).\n        right: Right operand (only when type in {CONJ, DISJ, IMPL}).\n    \"\"\"\n\n    type: str\n    name: str | None = None\n    sub: Sentence | None = None\n    left: Sentence | None = None\n    right: Sentence | None = None\n\n    def __str__(self) -&gt; str:\n        if self.type == ATOM:\n            return self.name  # type: ignore[return-value]\n        if self.type == NEG:\n            return f\"~{self.sub}\"\n        if self.type == CONJ:\n            return f\"({self.left} &amp; {self.right})\"\n        if self.type == DISJ:\n            return f\"({self.left} | {self.right})\"\n        if self.type == IMPL:\n            return f\"({self.left} -&gt; {self.right})\"\n        return f\"Sentence({self.type})\"  # pragma: no cover\n</code></pre>"},{"location":"api/syntax/#pynmms.syntax.parse_sentence","title":"<code>pynmms.syntax.parse_sentence(s)</code>","text":"<p>Parse a string into a propositional Sentence AST.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; parse_sentence(\"A\")\nSentence(type='atom', name='A', ...)\n&gt;&gt;&gt; parse_sentence(\"A -&gt; B\")\nSentence(type='impl', ..., left=Sentence(type='atom', name='A', ...),\n         right=Sentence(type='atom', name='B', ...))\n</code></pre> Source code in <code>pynmms/syntax.py</code> <pre><code>def parse_sentence(s: str) -&gt; Sentence:\n    \"\"\"Parse a string into a propositional Sentence AST.\n\n    Examples:\n        &gt;&gt;&gt; parse_sentence(\"A\")\n        Sentence(type='atom', name='A', ...)\n        &gt;&gt;&gt; parse_sentence(\"A -&gt; B\")\n        Sentence(type='impl', ..., left=Sentence(type='atom', name='A', ...),\n                 right=Sentence(type='atom', name='B', ...))\n    \"\"\"\n    s = s.strip()\n    if not s:\n        raise ValueError(\"Cannot parse empty sentence\")\n\n    # Strip outer parens if they wrap the entire expression\n    if s.startswith(\"(\") and s.endswith(\")\"):\n        depth = 0\n        all_wrapped = True\n        for i, c in enumerate(s):\n            if c == \"(\":\n                depth += 1\n            elif c == \")\":\n                depth -= 1\n            if depth == 0 and i &lt; len(s) - 1:\n                all_wrapped = False\n                break\n        if all_wrapped:\n            return parse_sentence(s[1:-1])\n\n    # --- Binary connectives at depth 0, lowest precedence first ---\n\n    # Implication (right-associative, lowest precedence)\n    # Scan left-to-right: first match gives right-associativity\n    depth = 0\n    for i in range(len(s)):\n        c = s[i]\n        if c == \"(\":\n            depth += 1\n        elif c == \")\":\n            depth -= 1\n        elif depth == 0 and s[i : i + 2] == \"-&gt;\":\n            left_str = s[:i].strip()\n            right_str = s[i + 2 :].strip()\n            if not left_str or not right_str:\n                raise ValueError(f\"Malformed implication in: {s!r}\")\n            return Sentence(\n                type=IMPL,\n                left=parse_sentence(left_str),\n                right=parse_sentence(right_str),\n            )\n\n    # Disjunction (left-associative) \u2014 find last '|' at depth 0\n    depth = 0\n    last_disj = -1\n    for i, c in enumerate(s):\n        if c == \"(\":\n            depth += 1\n        elif c == \")\":\n            depth -= 1\n        elif depth == 0 and c == \"|\":\n            last_disj = i\n    if last_disj &gt;= 0:\n        left_str = s[:last_disj].strip()\n        right_str = s[last_disj + 1 :].strip()\n        if not left_str or not right_str:\n            raise ValueError(f\"Malformed disjunction in: {s!r}\")\n        return Sentence(\n            type=DISJ,\n            left=parse_sentence(left_str),\n            right=parse_sentence(right_str),\n        )\n\n    # Conjunction (left-associative) \u2014 find last '&amp;' at depth 0\n    depth = 0\n    last_conj = -1\n    for i, c in enumerate(s):\n        if c == \"(\":\n            depth += 1\n        elif c == \")\":\n            depth -= 1\n        elif depth == 0 and c == \"&amp;\":\n            last_conj = i\n    if last_conj &gt;= 0:\n        left_str = s[:last_conj].strip()\n        right_str = s[last_conj + 1 :].strip()\n        if not left_str or not right_str:\n            raise ValueError(f\"Malformed conjunction in: {s!r}\")\n        return Sentence(\n            type=CONJ,\n            left=parse_sentence(left_str),\n            right=parse_sentence(right_str),\n        )\n\n    # Negation\n    if s.startswith(\"~\"):\n        sub_str = s[1:].strip()\n        if not sub_str:\n            raise ValueError(\"Negation with no operand\")\n        return Sentence(type=NEG, sub=parse_sentence(sub_str))\n\n    # Bare atom\n    return Sentence(type=ATOM, name=s)\n</code></pre>"},{"location":"api/syntax/#pynmms.syntax.is_atomic","title":"<code>pynmms.syntax.is_atomic(s)</code>","text":"<p>Return True if s parses to a bare atom (no logical connectives).</p> Source code in <code>pynmms/syntax.py</code> <pre><code>def is_atomic(s: str) -&gt; bool:\n    \"\"\"Return True if *s* parses to a bare atom (no logical connectives).\"\"\"\n    return parse_sentence(s).type == ATOM\n</code></pre>"},{"location":"api/syntax/#pynmms.syntax.all_atomic","title":"<code>pynmms.syntax.all_atomic(sentences)</code>","text":"<p>Return True if every sentence in sentences is atomic.</p> Source code in <code>pynmms/syntax.py</code> <pre><code>def all_atomic(sentences: frozenset[str]) -&gt; bool:\n    \"\"\"Return True if every sentence in *sentences* is atomic.\"\"\"\n    return all(is_atomic(s) for s in sentences)\n</code></pre>"},{"location":"theory/nmms-calculus/","title":"The NMMS Calculus","text":"<p>This page describes the theoretical foundations of pyNMMS, following Hlobil &amp; Brandom (2025), Chapter 3: \"Introducing Logical Vocabulary.\"</p>"},{"location":"theory/nmms-calculus/#overview","title":"Overview","text":"<p>NMMS (Non-Monotonic Multi-Succedent) is a sequent calculus for codifying open reason relations \u2014 consequence relations where Monotonicity ([Weakening]) and Transitivity ([Mixed-Cut]) can fail.</p>"},{"location":"theory/nmms-calculus/#material-base-definition-1","title":"Material Base (Definition 1)","text":"<p>A material base B =  consists of: <ul> <li>An atomic language L_B</li> <li>A base consequence relation |~_B \u2286 P(L_B) x P(L_B)</li> </ul> <p>satisfying Containment: Gamma \u2229 Delta \u2260 \u2205 implies Gamma |~_B Delta.</p> <p>The base encodes defeasible material inferences among atomic sentences as axioms.</p>"},{"location":"theory/nmms-calculus/#logical-extension","title":"Logical Extension","text":"<p>The rules of NMMS extend |~_B to a consequence relation |~ over a logically extended language L (adding ~, -&gt;, &amp;, |). A sequent Gamma =&gt; Delta is derivable iff there is a proof tree whose leaves are all axioms (base sequents).</p>"},{"location":"theory/nmms-calculus/#structural-rules-absent","title":"Structural Rules (Absent)","text":"<p>NMMS omits two structural rules:</p> <ul> <li>[Weakening]: Gamma |~ Delta does NOT imply Gamma, A |~ Delta. Adding premises can defeat inferences.</li> <li>[Mixed-Cut]: Gamma |~ A, Delta and Gamma', A |~ Delta' does NOT imply Gamma, Gamma' |~ Delta, Delta'. Chaining good inferences can yield bad ones.</li> </ul>"},{"location":"theory/nmms-calculus/#propositional-rules","title":"Propositional Rules","text":"<p>All rules are Ketonen-style. Multi-premise rules include a third top sequent containing all active formulae from the other premises on the same sides. This compensates for the absence of structural contraction.</p>"},{"location":"theory/nmms-calculus/#left-rules","title":"Left Rules","text":"<p>[L~] Negation left:</p> <pre><code>    Gamma =&gt; Delta, A\n    -----------------\n    Gamma, ~A =&gt; Delta\n</code></pre> <p>[L-&gt;] Implication left (3 premises):</p> <pre><code>    Gamma =&gt; Delta, A     Gamma, B =&gt; Delta     Gamma, B =&gt; Delta, A\n    -----------------------------------------------------------------\n                      Gamma, A -&gt; B =&gt; Delta\n</code></pre> <p>[L&amp;] Conjunction left:</p> <pre><code>    Gamma, A, B =&gt; Delta\n    --------------------\n    Gamma, A &amp; B =&gt; Delta\n</code></pre> <p>[L|] Disjunction left (3 premises):</p> <pre><code>    Gamma, A =&gt; Delta     Gamma, B =&gt; Delta     Gamma, A, B =&gt; Delta\n    -----------------------------------------------------------------\n                      Gamma, A | B =&gt; Delta\n</code></pre>"},{"location":"theory/nmms-calculus/#right-rules","title":"Right Rules","text":"<p>[R~] Negation right:</p> <pre><code>    Gamma, A =&gt; Delta\n    -----------------\n    Gamma =&gt; Delta, ~A\n</code></pre> <p>[R-&gt;] Implication right:</p> <pre><code>    Gamma, A =&gt; Delta, B\n    --------------------\n    Gamma =&gt; Delta, A -&gt; B\n</code></pre> <p>[R&amp;] Conjunction right (3 premises):</p> <pre><code>    Gamma =&gt; Delta, A     Gamma =&gt; Delta, B     Gamma =&gt; Delta, A, B\n    -----------------------------------------------------------------\n                      Gamma =&gt; Delta, A &amp; B\n</code></pre> <p>[R|] Disjunction right:</p> <pre><code>    Gamma =&gt; Delta, A, B\n    --------------------\n    Gamma =&gt; Delta, A | B\n</code></pre>"},{"location":"theory/nmms-calculus/#critical-properties","title":"Critical Properties","text":""},{"location":"theory/nmms-calculus/#supraclassicality-fact-2","title":"Supraclassicality (Fact 2)","text":"<p>CL \u2286 |~ \u2014 all classically valid sequents are derivable when the base obeys Containment. The \"narrowly logical part\" (derivable from Containment alone) is exactly classical propositional logic.</p>"},{"location":"theory/nmms-calculus/#conservative-extension-fact-3-prop-26","title":"Conservative Extension (Fact 3 / Prop. 26)","text":"<p>If Gamma \u222a Delta \u2286 L_B, then Gamma |~ Delta iff Gamma |~_B Delta. Adding logical vocabulary does not change base-level reason relations.</p>"},{"location":"theory/nmms-calculus/#invertibility-prop-27","title":"Invertibility (Prop. 27)","text":"<p>All NMMS rules are invertible \u2014 the bottom sequent is derivable iff all top sequents are derivable.</p>"},{"location":"theory/nmms-calculus/#projection-theorem-7","title":"Projection (Theorem 7)","text":"<p>Every sequent Gamma =&gt; Delta in the extended language uniquely decomposes into a set of base-vocabulary sequents (AtomicImp) such that Gamma =&gt; Delta is derivable iff AtomicImp \u2286 |~_B.</p>"},{"location":"theory/nmms-calculus/#explicitation-conditions","title":"Explicitation Conditions","text":"<p>These biconditionals show how logical vocabulary \"makes explicit\" reason relations:</p> <ul> <li>DD (Deduction-Detachment): Gamma |~ A -&gt; B, Delta iff Gamma, A |~ B, Delta</li> <li>II (Incoherence-Incompatibility): Gamma |~ ~A, Delta iff Gamma, A |~ Delta</li> <li>AA (Antecedent-Adjunction): Gamma, A &amp; B |~ Delta iff Gamma, A, B |~ Delta</li> <li>SS (Succedent-Summation): Gamma |~ A | B, Delta iff Gamma |~ A, B, Delta</li> </ul>"},{"location":"theory/nmms-calculus/#references","title":"References","text":"<ul> <li>Hlobil, U. &amp; Brandom, R. B. (2025). Reasons for Logic, Logic for Reasons. Chapter 3: \"Introducing Logical Vocabulary.\"</li> </ul>"},{"location":"theory/onto-extension/","title":"The NMMS_Onto Extension: Schema-Level Macros for Material Inferential Commitments","text":""},{"location":"theory/onto-extension/#1-introduction","title":"1. Introduction","text":"<p>NMMS (Non-Monotonic Multi-Succedent) provides a proof-theoretic framework for codifying open reason relations -- consequence relations where Monotonicity ([Weakening]) and Transitivity ([Mixed-Cut]) can fail. Hlobil &amp; Brandom (2025), Chapter 3 (\"Introducing Logical Vocabulary\"), develops the propositional fragment: a sequent calculus whose eight Ketonen-style rules extend an arbitrary material base B =  to a full propositional consequence relation |~. The calculus enjoys Supraclassicality, Conservative Extension, Invertibility, and a Projection theorem reducing derivability to base-level axiom checking. <p>NMMS_Onto is an ontology engineering extension that enriches the material base with schema-level macros for expressing material inferential commitments and incompatibilities. The extension adds no new proof rules: the same eight propositional rules apply unchanged. Instead, six ontology schema types -- <code>subClassOf</code>, <code>range</code>, <code>domain</code>, <code>subPropertyOf</code>, <code>disjointWith</code>, <code>disjointProperties</code> -- are registered as schematic patterns that the material base evaluates lazily when checking whether a sequent is an axiom. Because the extension operates entirely at the level of the base, all of Hlobil's proofs for the propositional calculus are preserved without modification.</p> <p>The vocabulary is borrowed from W3C RDFS and OWL for familiarity, but the semantics are those of NMMS: exact-match defeasibility, no weakening, no transitivity. These are not limitations to be worked around -- they are the defining features of the NMMS framework that make it suitable for modeling open reason relations.</p> <p>The resulting system, NMMS_Onto, occupies a distinctive niche: it supports defeasible ontological reasoning (class hierarchies, role constraints, property hierarchies, concept and property incompatibilities) within a framework where adding premises can defeat inferences and chaining good inferences can yield bad ones -- precisely the features that distinguish NMMS from classical and monotonic nonclassical logics.</p>"},{"location":"theory/onto-extension/#2-design-decision-axiom-extensions-not-proof-rules","title":"2. Design Decision: Axiom Extensions, Not Proof Rules","text":"<p>The central architectural decision in NMMS_Onto is to extend the material base rather than the proof rules. To appreciate why this matters, it helps to recall the structure of NMMS proof trees.</p> <p>An NMMS proof tree has two kinds of nodes:</p> <ul> <li> <p>Leaves (axioms): Sequents that hold by virtue of the base alone. These are checked by <code>is_axiom(Gamma, Delta)</code>, which succeeds if (a) Gamma and Delta overlap (Containment), or (b) the pair (Gamma, Delta) is explicitly in |~_B (exact match).</p> </li> <li> <p>Internal nodes (rule applications): Sequents derived by applying one of the eight Ketonen-style propositional rules to reduce a complex sequent to simpler subgoals. The rules decompose logical connectives (~, -&gt;, &amp;, |) until only atomic sentences remain.</p> </li> </ul> <p>Hlobil's Chapter 3 proofs -- Supraclassicality (Fact 2), Conservative Extension (Fact 3 / Prop. 26), Invertibility (Prop. 27), and the Projection Theorem (Theorem 7) -- are established for any material base satisfying the Containment axiom (Definition 1). The proofs make no assumptions about the internal structure of base-level axioms beyond Containment. This means that any extension of |~_B that preserves Containment automatically inherits all of these results.</p> <p>NMMS_Onto exploits this observation. The six ontology schemas add new pairs to the base consequence relation |~_B. Each schema generates axioms of the form {s} |~ {t} (for inferential commitment schemas) or {s, t} |~ {} (for incompatibility schemas) where s and t are atomic sentences. Since the inferential commitment schemas produce pairs with disjoint singleton antecedent and consequent sets, and the incompatibility schemas produce pairs with empty consequent, none of these conflict with Containment (which only requires that overlapping pairs be included). The schemas therefore extend |~_B while preserving Containment, and all of Hlobil's metatheoretic results carry over without any additional proof work.</p> <p>By contrast, introducing new proof rules -- for instance, unrestricted quantifier rules [forall-L], [forall-R], [exists-L], [exists-R] -- would modify the internal structure of proof trees. This would require:</p> <ol> <li>Re-establishing Invertibility for the new rules.</li> <li>Re-proving the Projection Theorem with a modified AtomicImp decomposition.</li> <li>Verifying that Supraclassicality and Conservative Extension still hold with the expanded rule set.</li> <li>Ensuring that the third-top-sequent pattern (which compensates for the absence of structural contraction) interacts correctly with the new rules.</li> </ol> <p>None of this work is necessary for NMMS_Onto, because the proof rules are left unchanged. The ontology schemas are visible only to the axiom checker, not to the proof search engine.</p> <p>Implementation consequence: In <code>pyNMMS</code>, the <code>NMMSReasoner</code> class from the propositional core works without modification with <code>OntoMaterialBase</code>. No subclassing of the reasoner is required. The only change is that <code>OntoMaterialBase.is_axiom()</code> adds a third axiom check (Ax3: ontology schema match) after the standard Ax1 (Containment) and Ax2 (explicit base consequence).</p>"},{"location":"theory/onto-extension/#3-the-nmms_onto-material-base","title":"3. The NMMS_Onto Material Base","text":"<p>An NMMS_Onto material base B_Onto =  extends the standard NMMS material base with a set S of ontology schemas that serve as macros for generating material inferential commitments and incompatibilities. The atomic language L_B is partitioned into two syntactic categories: <p>ABox assertions (ground facts about individuals):</p> <ul> <li>Concept assertions: <code>C(a)</code> -- individual <code>a</code> belongs to concept <code>C</code>. Examples: <code>Man(socrates)</code>, <code>Happy(alice)</code>, <code>HeartAttack(patient)</code>.</li> <li>Role assertions: <code>R(a,b)</code> -- individual <code>a</code> stands in role <code>R</code> to individual <code>b</code>. Examples: <code>hasChild(alice,bob)</code>, <code>hasSymptom(patient,chestPain)</code>.</li> </ul> <p>TBox schemas (schema-level macros for material inferential commitments and incompatibilities):</p> <p>The TBox consists of six ontology schema types. Each schema is evaluated lazily at query time -- not eagerly grounded over all known individuals. All schemas use exact match (no weakening), which is what preserves nonmonotonicity.</p>"},{"location":"theory/onto-extension/#31-subclassofc-d","title":"3.1 subClassOf(C, D)","text":"<p>Schema: For any individual x,</p> <pre><code>{C(x)} |~_B {D(x)}\n</code></pre> <p>Intended reading: Being a C is a defeasible material inferential commitment to being a D.</p> <p>Example: <code>subClassOf(Man, Mortal)</code> generates the axiom <code>{Man(socrates)} |~ {Mortal(socrates)}</code> for any individual <code>socrates</code>, without needing to enumerate all individuals in advance.</p>"},{"location":"theory/onto-extension/#32-ranger-c","title":"3.2 range(R, C)","text":"<p>Schema: For any individuals x, y,</p> <pre><code>{R(x,y)} |~_B {C(y)}\n</code></pre> <p>Intended reading: Standing in role R to something carries a defeasible material inferential commitment that the second argument is a C.</p> <p>Example: <code>range(hasChild, Person)</code> generates <code>{hasChild(alice,bob)} |~ {Person(bob)}</code> -- if alice has a child bob, then bob is (defeasibly) a Person.</p>"},{"location":"theory/onto-extension/#33-domainr-c","title":"3.3 domain(R, C)","text":"<p>Schema: For any individuals x, y,</p> <pre><code>{R(x,y)} |~_B {C(x)}\n</code></pre> <p>Intended reading: Standing in role R to something carries a defeasible material inferential commitment that the first argument is a C.</p> <p>Example: <code>domain(hasChild, Parent)</code> generates <code>{hasChild(alice,bob)} |~ {Parent(alice)}</code> -- if alice has a child, then alice is (defeasibly) a Parent.</p>"},{"location":"theory/onto-extension/#34-subpropertyofr-s","title":"3.4 subPropertyOf(R, S)","text":"<p>Schema: For any individuals x, y,</p> <pre><code>{R(x,y)} |~_B {S(x,y)}\n</code></pre> <p>Intended reading: An R-assertion carries a defeasible material inferential commitment to the corresponding S-assertion.</p> <p>Example: <code>subPropertyOf(hasChild, hasDescendant)</code> generates <code>{hasChild(alice,bob)} |~ {hasDescendant(alice,bob)}</code> -- if alice has child bob, then alice (defeasibly) has descendant bob.</p>"},{"location":"theory/onto-extension/#35-disjointwithc-d","title":"3.5 disjointWith(C, D)","text":"<p>Schema: For any individual x,</p> <pre><code>{C(x), D(x)} |~_B {}\n</code></pre> <p>Intended reading: Being a C and being a D are materially incompatible. This is an incompatibility commitment -- the empty consequent means the pair of premises is incoherent.</p> <p>Incompatibility is foundational in Brandom's framework: it is prior to negation, not derived from it. The <code>disjointWith</code> schema directly encodes material incompatibility between concepts without routing through negation.</p> <p>Example: <code>disjointWith(Alive, Dead)</code> generates <code>{Alive(socrates), Dead(socrates)} |~ {}</code> -- being alive and being dead are incompatible for any individual.</p>"},{"location":"theory/onto-extension/#36-disjointpropertiesr-s","title":"3.6 disjointProperties(R, S)","text":"<p>Schema: For any individuals x, y,</p> <pre><code>{R(x,y), S(x,y)} |~_B {}\n</code></pre> <p>Intended reading: Standing in role R and role S to the same pair of individuals is materially incompatible.</p> <p>Example: <code>disjointProperties(employs, isEmployedBy)</code> generates <code>{employs(alice,bob), isEmployedBy(alice,bob)} |~ {}</code> -- alice cannot both employ bob and be employed by bob.</p>"},{"location":"theory/onto-extension/#4-containment-preservation","title":"4. Containment Preservation","text":"<p>Claim: If B =  satisfies Containment, then the extended base B_Onto =  also satisfies Containment, where S_ground denotes the set of all ground instances of the registered ontology schemas. <p>Proof sketch: Containment requires that Gamma |~_B Delta whenever Gamma intersection Delta is nonempty. We must show two things:</p> <ol> <li> <p>The original Containment pairs are preserved: B_Onto extends |~_B, so all original pairs remain.</p> </li> <li> <p>The new schema pairs do not violate Containment: Each inferential commitment schema adds pairs of the form ({s}, {t}) where s and t are distinct atomic sentences (e.g., s = <code>Man(socrates)</code> and t = <code>Mortal(socrates)</code> for a subClassOf schema). Since s != t, we have {s} intersection {t} = empty, so these pairs are in the region where Containment is silent. Each incompatibility schema adds pairs of the form ({s, t}, {}) where s and t are distinct atomic sentences. Since the consequent is empty, {s, t} intersection {} = empty, so again Containment is silent. Adding pairs where Containment is silent cannot violate the requirement that pairs with nonempty intersection are included.</p> </li> </ol> <p>More precisely, Containment states: for all Gamma, Delta in P(L_B), if Gamma intersection Delta != empty then Gamma |~_B Delta. The ontology schemas only add pairs where the intersection is empty. So the condition \"if Gamma intersection Delta != empty then Gamma |~_B Delta\" is unaffected: the \"if\" side is unchanged (no new Gamma, Delta with nonempty intersection are introduced that were not already covered), and the \"then\" side is only strengthened (more pairs are in |~_B, not fewer).</p> <p>Corollary: Since B_Onto satisfies Containment, all of the following results from Hlobil &amp; Brandom (2025), Ch. 3, hold for NMMS_Onto without modification:</p> <ul> <li>Fact 2 (Supraclassicality): CL is a subset of |~. All classically valid sequents are derivable.</li> <li>Fact 3 / Proposition 26 (Conservative Extension): If Gamma union Delta is a subset of L_B, then Gamma |~ Delta iff Gamma |~_B Delta. Logical vocabulary does not alter base-level reason relations.</li> <li>Proposition 27 (Invertibility): All NMMS rules are invertible.</li> <li>Theorem 7 (Projection): Every sequent in the logically extended language decomposes into a set of base-vocabulary sequents (AtomicImp) such that derivability reduces to checking AtomicImp against |~_B.</li> </ul>"},{"location":"theory/onto-extension/#5-key-properties","title":"5. Key Properties","text":""},{"location":"theory/onto-extension/#51-defeasibility","title":"5.1 Defeasibility","text":"<p>All ontology schemas are defeasible: adding premises to the antecedent side of a derivable sequent can defeat the inference. This is because the <code>is_axiom</code> check uses exact match -- a schema <code>{C(x)} |~ {D(x)}</code> matches only when the antecedent is exactly <code>{C(x)}</code> and the consequent is exactly <code>{D(x)}</code>, with no additional sentences on either side.</p> <p>Example: With <code>subClassOf(Man, Mortal)</code>:</p> <ul> <li><code>{Man(socrates)} |~ {Mortal(socrates)}</code> -- derivable (schema match).</li> <li><code>{Man(socrates), Immortal(socrates)} |~ {Mortal(socrates)}</code> -- not derivable. The antecedent <code>{Man(socrates), Immortal(socrates)}</code> does not match the schema's singleton antecedent pattern.</li> </ul> <p>This is not a bug but a feature: learning that Socrates is immortal defeats the defeasible inference that he is mortal. The exact-match semantics of the material base (inherited from Hlobil's framework) is what makes this possible without any explicit defeat mechanism or priority ordering.</p>"},{"location":"theory/onto-extension/#52-non-transitivity","title":"5.2 Non-transitivity","text":"<p>Because NMMS lacks [Mixed-Cut], chaining two individually valid schema applications does not yield a valid inference. Schemas compose only when the intermediate step is explicitly recorded in the base as an axiom.</p> <p>Example: With <code>subClassOf(Man, Mortal)</code> and <code>subClassOf(Mortal, Physical)</code>:</p> <ul> <li><code>{Man(socrates)} |~ {Mortal(socrates)}</code> -- derivable (first schema).</li> <li><code>{Mortal(socrates)} |~ {Physical(socrates)}</code> -- derivable (second schema).</li> <li><code>{Man(socrates)} |~ {Physical(socrates)}</code> -- not derivable. There is no axiom matching <code>({Man(socrates)}, {Physical(socrates)})</code>, and backward proof search cannot chain the two schemas because the calculus lacks [Mixed-Cut].</li> </ul> <p>Similarly, <code>subPropertyOf(hasChild, hasDescendant)</code> and <code>subPropertyOf(hasDescendant, hasRelative)</code> do not jointly entail <code>{hasChild(alice,bob)} |~ {hasRelative(alice,bob)}</code>.</p> <p>This distinguishes NMMS_Onto from systems where <code>subClassOf</code> is transitive. In NMMS_Onto, if one wants the transitive closure, one must explicitly register each link: <code>subClassOf(Man, Mortal)</code>, <code>subClassOf(Man, Physical)</code>, and <code>subClassOf(Mortal, Physical)</code> as separate schemas. This is by design -- some subclass chains should compose, and others should not, depending on the domain.</p>"},{"location":"theory/onto-extension/#53-incompatibility-as-foundational","title":"5.3 Incompatibility as Foundational","text":"<p>The <code>disjointWith</code> and <code>disjointProperties</code> schemas encode material incompatibility directly, without routing through negation. In Brandom's inferentialist framework, incompatibility is prior to negation: two commitments are incompatible when holding both leads to incoherence (empty consequent). Negation is then understood in terms of incompatibility, not the other way around.</p> <p>Example: With <code>disjointWith(Alive, Dead)</code>:</p> <ul> <li><code>{Alive(socrates), Dead(socrates)} |~ {}</code> -- the pair is incoherent (schema match).</li> <li>This incompatibility is defeasible: <code>{Alive(socrates), Dead(socrates), Zombie(socrates)} |~ {}</code> is not an axiom. The extra premise <code>Zombie(socrates)</code> defeats the incompatibility, because the antecedent no longer exactly matches the schema pattern.</li> </ul> <p>This models a natural reasoning pattern: being alive and being dead are ordinarily incompatible, but in certain contexts (zombies, theological resurrection) the incompatibility may not hold.</p>"},{"location":"theory/onto-extension/#54-lazy-evaluation","title":"5.4 Lazy Evaluation","text":"<p>Ontology schemas are stored as abstract patterns and evaluated lazily during <code>is_axiom</code> checks. This means:</p> <ul> <li>Storage: O(k) schemas, where k is the number of registered schemas. Not O(n * k) ground entries, where n is the number of known individuals.</li> <li>Adding individuals: O(1). When a new individual enters the language (e.g., <code>Man(plato)</code> is added), no schema re-expansion or re-grounding is needed. The schema <code>subClassOf(Man, Mortal)</code> will automatically match <code>{Man(plato)} |~ {Mortal(plato)}</code> at query time.</li> <li>Query time: Each <code>is_axiom</code> call iterates over the registered schemas and attempts pattern matching against the concrete antecedent and consequent. For singleton pairs (the only ones inferential commitment schemas generate), this is O(k) per axiom check.</li> </ul> <p>This lazy evaluation strategy avoids the combinatorial explosion that would arise from eagerly grounding all schemas over all known individuals, especially in bases with many individuals and many schemas.</p>"},{"location":"theory/onto-extension/#55-deduction-detachment-theorem-ddt","title":"5.5 Deduction-Detachment Theorem (DDT)","text":"<p>The DDT -- Gamma |~ A -&gt; B, Delta iff Gamma, A |~ B, Delta -- is a property of the proof rules ([R-&gt;] and [L-&gt;]), not of the base. Since NMMS_Onto does not modify the proof rules, DDT holds automatically.</p> <p>Example: With <code>subClassOf(Man, Mortal)</code>:</p> <ul> <li><code>{Man(socrates)} |~ {Mortal(socrates)}</code> is derivable (schema match).</li> <li>Therefore, by DDT, <code>{} |~ {Man(socrates) -&gt; Mortal(socrates)}</code> is also derivable.</li> </ul> <p>The backward proof proceeds: [R-&gt;] decomposes <code>{} =&gt; {Man(socrates) -&gt; Mortal(socrates)}</code> into <code>{Man(socrates)} =&gt; {Mortal(socrates)}</code>, which is an axiom via the subClassOf schema. This means that NMMS_Onto can express ontology schema relationships as object-language implications -- the logical vocabulary \"makes explicit\" the defeasible material inferences encoded in the schemas.</p>"},{"location":"theory/onto-extension/#6-schemas-as-macros-no-new-reasoning-capabilities","title":"6. Schemas as Macros: No New Reasoning Capabilities","text":"<p>It is important to emphasize that NMMS_Onto schemas add no new reasoning capabilities to the NMMS framework. They are macros -- convenient shorthand for generating families of ordinary base axioms. Everything that can be expressed with a schema could equally be expressed by manually adding the corresponding ground axioms to the base.</p> <p>The value of schemas is purely ergonomic:</p> <ul> <li>Conciseness: A single <code>subClassOf(Man, Mortal)</code> schema replaces potentially many ground axioms <code>{Man(socrates)} |~ {Mortal(socrates)}</code>, <code>{Man(plato)} |~ {Mortal(plato)}</code>, etc.</li> <li>Open-endedness: Schemas apply to individuals not yet known at registration time. When a new individual appears in the language, the schema automatically generates the corresponding axiom without explicit registration.</li> <li>Ontological vocabulary: The schema names (<code>subClassOf</code>, <code>range</code>, <code>domain</code>, <code>subPropertyOf</code>, <code>disjointWith</code>, <code>disjointProperties</code>) provide a familiar vocabulary for expressing common patterns of material inferential commitment and incompatibility.</li> </ul> <p>But the underlying reasoning mechanism is unchanged: the same eight Ketonen-style propositional rules, the same backward proof search, the same axiom checking. The schemas simply expand the set of pairs that count as axioms.</p>"},{"location":"theory/onto-extension/#7-what-nmms_onto-does-not-include","title":"7. What NMMS_Onto Does NOT Include","text":"<p>To be explicit about the boundaries of the extension:</p> <ul> <li> <p>No unrestricted quantifiers: NMMS_Onto does not add universal or existential quantifier rules (forall-L, forall-R, exists-L, exists-R). Hlobil identifies fundamental problems with unrestricted quantification in nonmonotonic settings: unrestricted forall-R overgeneralizes from specific instances, and unrestricted forall-L smuggles in defeating information via universal instantiation. NMMS_Onto avoids these problems entirely by working at the schema level rather than adding quantifier proof rules.</p> </li> <li> <p>No ALL/SOME proof rules: Unlike ALC-style restricted quantifier extensions, NMMS_Onto does not include proof rules for restricted universal (<code>ALL R.C</code>) or restricted existential (<code>SOME R.C</code>) expressions. These would require new internal proof tree nodes, revalidation of Invertibility and Projection, and careful treatment of the third-top-sequent pattern. The ontology schema approach achieves useful ontological reasoning without this complexity.</p> </li> <li> <p>No transitive closure: <code>subClassOf</code> and <code>subPropertyOf</code> are not transitively closed. Each link must be explicitly registered. This is a consequence of the absence of [Mixed-Cut] and is a deliberate design feature of the NMMS framework.</p> </li> <li> <p>No concept intersection, union, or complement: NMMS_Onto does not support complex concept expressions such as <code>C AND D</code>, <code>C OR D</code>, or <code>NOT C</code>. The propositional connectives (~, &amp;, |, -&gt;) are available in the proof rules and can combine atomic sentences, but there is no mechanism for constructing complex concepts from simpler ones within the ontology schema language itself.</p> </li> <li> <p>No cardinality restrictions or nominals: Features such as <code>MIN n R.C</code>, <code>MAX n R.C</code>, <code>EXACTLY n R.C</code>, or <code>{a}</code> (nominals) from expressive DLs (SHOIN, SROIQ) are not included.</p> </li> <li> <p>No role characteristics: NMMS_Onto does not support role transitivity, symmetry, reflexivity, inverseness, functionality, or role chains as built-in features. If <code>R</code> should be symmetric, both <code>{R(a,b)} |~ {R(b,a)}</code> and <code>{R(b,a)} |~ {R(a,b)}</code> must be registered as explicit ground consequences or handled through additional schemas.</p> </li> </ul>"},{"location":"theory/onto-extension/#8-assumptions-and-open-questions","title":"8. Assumptions and Open Questions","text":""},{"location":"theory/onto-extension/#assumptions","title":"Assumptions","text":"<ol> <li> <p>Containment suffices: The Containment axiom (Definition 1 in Ch. 3) is the only structural requirement on the material base. We assume that Hlobil's proofs depend on no other properties of |~_B beyond Containment and the specific form of the proof rules. This assumption is supported by the text of Ch. 3, which states the results for \"any material base satisfying Containment.\"</p> </li> <li> <p>Exact match is the right notion of defeasibility: The schemas use singleton antecedent and singleton consequent (for inferential commitment schemas) or pair antecedent and empty consequent (for incompatibility schemas) with no weakening. This means that any additional premise defeats the inference or incompatibility. In practice, one might want finer-grained defeat: <code>{Man(socrates), Greek(socrates)} |~ {Mortal(socrates)}</code> might be desired even though the schema only directly generates the singleton-antecedent form. Users can accommodate this by adding explicit ground consequences for the desired multi-premise patterns.</p> </li> <li> <p>Propositional connectives are sufficient for logical structure: The claim is that the six ontology schemas, combined with propositional connectives via the eight proof rules, provide adequate expressive power for a useful fragment of ontological reasoning. This is an empirical claim that depends on the intended applications.</p> </li> </ol>"},{"location":"theory/onto-extension/#open-questions","title":"Open Questions","text":"<ol> <li> <p>Schema interaction principles: Should there be systematic rules for how schemas interact? For instance, should <code>subClassOf(C, D)</code> and <code>domain(R, C)</code> jointly entail anything about <code>R</code> and <code>D</code>? In classical ontology languages, they do (via monotonic closure). In NMMS_Onto, they do not, by design. But are there principled middle grounds -- forms of controlled interaction that preserve the nonmonotonic character while recovering some useful entailments?</p> </li> <li> <p>Retraction semantics: The <code>CommitmentStore</code> supports retracting schemas by source label. What are the formal properties of retraction? Does retracting a schema correspond to a well-defined operation on the consequence relation? How does retraction interact with cached proof results?</p> </li> <li> <p>Relationship to preferential and rational consequence relations: The defeasible description logic literature (Casini &amp; Straccia 2010, Giordano et al. 2013) works with preferential and rational consequence relations from the KLM framework. How does the NMMS notion of defeasibility (failure of Weakening) relate to the KLM notion (failure of Monotonicity in preferential models)? Are there translations or embeddings between the two frameworks?</p> </li> <li> <p>Completeness relative to intended models: NMMS_Onto is sound by construction (all axioms are explicitly registered). But is there a natural model-theoretic semantics for ontology schemas in the NMMS framework, and if so, is the system complete with respect to that semantics?</p> </li> <li> <p>Scaling properties: The lazy evaluation strategy avoids combinatorial explosion in schema grounding, but the proof search itself has exponential worst-case complexity (due to the multi-premise Ketonen rules for [L-&gt;], [L|], [R&amp;]). How does the addition of ontology schemas affect proof search performance in practice? Are there heuristics for ordering schema checks to improve average-case behavior?</p> </li> </ol>"},{"location":"theory/onto-extension/#9-references","title":"9. References","text":"<ul> <li> <p>Hlobil, U. &amp; Brandom, R. B. (2025). Reasons for Logic, Logic for Reasons. Chapter 3: \"Introducing Logical Vocabulary.\"</p> </li> <li> <p>Casini, G. &amp; Straccia, U. (2010). Rational Closure for Defeasible Description Logics. In Proceedings of the 12th European Conference on Logics in Artificial Intelligence (JELIA), pp. 77--90. Springer.</p> </li> <li> <p>Giordano, L., Gliozzi, V., Olivetti, N., &amp; Pozzato, G. L. (2013). A Non-Monotonic Description Logic for Reasoning About Typicality. Artificial Intelligence, 195, 165--202.</p> </li> </ul>"},{"location":"tutorial/chapter3-walkthrough/","title":"Exploring Chapter 3 with the CLI","text":"<p>This tutorial walks through the worked examples from Hlobil &amp; Brandom 2025, Chapter 3 (\"Introducing Logical Vocabulary\") using the <code>pynmms</code> CLI. By the end you will have built Toy Base T, verified its consequences, demonstrated monotonicity and transitivity failures, and used logical vocabulary to make those failures explicit.</p>"},{"location":"tutorial/chapter3-walkthrough/#1-building-toy-base-t","title":"1. Building Toy Base T","text":"<p>Toy Base T from p. 118 has 7 atoms and 5 consequences. Start an interactive session:</p> <pre><code>$ pynmms repl\nStarting with empty base.\npyNMMS REPL. Type 'help' for commands.\n\npynmms&gt; tell atom p \"Tara is human\"\nAdded atom: p \u2014 Tara is human\npynmms&gt; tell atom q \"Tara's body temp is 37\u00b0C\"\nAdded atom: q \u2014 Tara's body temp is 37\u00b0C\npynmms&gt; tell atom v \"Tara is healthy\"\nAdded atom: v \u2014 Tara is healthy\npynmms&gt; tell atom s \"X is a triangle\"\nAdded atom: s \u2014 X is a triangle\npynmms&gt; tell atom t \"angle-sum of X exceeds two right angles\"\nAdded atom: t \u2014 angle-sum of X exceeds two right angles\npynmms&gt; tell atom w \"angle-sum of X equals two right angles\"\nAdded atom: w \u2014 angle-sum of X equals two right angles\npynmms&gt; tell atom x \"X is a Euclidean plane triangle\"\nAdded atom: x \u2014 X is a Euclidean plane triangle\n</code></pre> <p>Now add the five base consequences. Note that <code>s, t |~</code> has an empty consequent \u2014 this encodes an incompatibility (s and t cannot hold together):</p> <pre><code>pynmms&gt; tell p |~ q\nAdded: {'p'} |~ {'q'}\npynmms&gt; tell s, t |~\nAdded: set() |~ set()\npynmms&gt; tell p, q |~ v\nAdded: {'p', 'q'} |~ {'v'}\npynmms&gt; tell s |~ w\nAdded: {'s'} |~ {'w'}\npynmms&gt; tell s, w |~ x\nAdded: {'s', 'w'} |~ {'x'}\n</code></pre> <p>Verify everything with <code>show</code>:</p> <pre><code>pynmms&gt; show\nLanguage (7 atoms):\n  p \u2014 Tara is human\n  q \u2014 Tara's body temp is 37\u00b0C\n  s \u2014 X is a triangle\n  t \u2014 angle-sum of X exceeds two right angles\n  v \u2014 Tara is healthy\n  w \u2014 angle-sum of X equals two right angles\n  x \u2014 X is a Euclidean plane triangle\nConsequences (5):\n  {'p'} |~ {'q'}\n  {'p', 'q'} |~ {'v'}\n  {'s'} |~ {'w'}\n  {'s', 't'} |~ set()\n  {'s', 'w'} |~ {'x'}\n</code></pre> <p>Save for later use:</p> <pre><code>pynmms&gt; save toyT.json\nSaved to toyT.json\n</code></pre>"},{"location":"tutorial/chapter3-walkthrough/#2-base-consequences","title":"2. Base consequences","text":"<p>Verify the five explicit consequences are derivable:</p> <pre><code>pynmms&gt; ask p =&gt; q\nDERIVABLE\npynmms&gt; ask p, q =&gt; v\nDERIVABLE\npynmms&gt; ask s =&gt; w\nDERIVABLE\npynmms&gt; ask s, t =&gt;\nDERIVABLE\npynmms&gt; ask s, w =&gt; x\nDERIVABLE\n</code></pre>"},{"location":"tutorial/chapter3-walkthrough/#3-monotonicity-failures","title":"3. Monotonicity failures","text":"<p>NMMS omits [Weakening], so adding premises can defeat inferences.</p> <p>MO-failure-1: <code>p |~ q</code> but <code>p, r \u0338|~ q</code> \u2014 adding atom <code>r</code> defeats the inference:</p> <pre><code>pynmms&gt; ask p =&gt; q\nDERIVABLE\npynmms&gt; ask p, r =&gt; q\nNOT DERIVABLE\n</code></pre> <p>This happens because the base relation uses exact syntactic match \u2014 the pair <code>({p, r}, {q})</code> is not in the base, and there is no Weakening rule to derive it from <code>({p}, {q})</code>.</p>"},{"location":"tutorial/chapter3-walkthrough/#4-transitivity-failures","title":"4. Transitivity failures","text":"<p>NMMS omits [Mixed-Cut], so chaining good inferences can yield bad ones.</p> <p>CT-failure-1: <code>p |~ q</code> and <code>p, q |~ v</code> but <code>p \u0338|~ v</code>:</p> <pre><code>pynmms&gt; ask p =&gt; q\nDERIVABLE\npynmms&gt; ask p, q =&gt; v\nDERIVABLE\npynmms&gt; ask p =&gt; v\nNOT DERIVABLE\n</code></pre> <p>Intuitively: Tara is human, so normally her body temp is 37\u00b0C. And if Tara is human and her body temp is 37\u00b0C, she is healthy. But we cannot conclude from Tara being human alone that she is healthy \u2014 her body temp might not be 37\u00b0C (she might have a fever).</p>"},{"location":"tutorial/chapter3-walkthrough/#5-explicitation-with-logical-vocabulary","title":"5. Explicitation with logical vocabulary","text":"<p>The NMMS rules let logical vocabulary \"make explicit\" the reason relations in the base.</p> <p>DD (Deduction-Detachment): Since <code>p |~ q</code>, we have <code>|~ p -&gt; q</code>:</p> <pre><code>pynmms&gt; ask =&gt; p -&gt; q\nDERIVABLE\n</code></pre> <p>II (Incoherence-Incompatibility): Since <code>s, t |~</code> (s and t are incompatible), we have <code>|~ ~(s &amp; t)</code>:</p> <pre><code>pynmms&gt; ask =&gt; ~(s &amp; t)\nDERIVABLE\n</code></pre>"},{"location":"tutorial/chapter3-walkthrough/#6-batch-base-creation","title":"6. Batch base creation","text":"<p>Instead of typing each line interactively, create a <code>.base</code> file:</p> <pre><code># toyT.base \u2014 Toy Base T from Hlobil &amp; Brandom 2025, Ch. 3\natom p \"Tara is human\"\natom q \"Tara's body temp is 37\u00b0C\"\natom v \"Tara is healthy\"\natom s \"X is a triangle\"\natom t \"angle-sum of X exceeds two right angles\"\natom w \"angle-sum of X equals two right angles\"\natom x \"X is a Euclidean plane triangle\"\np |~ q\ns, t |~\np, q |~ v\ns |~ w\ns, w |~ x\n</code></pre> <p>Then load it in one command:</p> <pre><code>pynmms tell -b toyT.json --create --batch toyT.base\n</code></pre>"},{"location":"tutorial/chapter3-walkthrough/#7-scripting-with-exit-codes-and-json","title":"7. Scripting with exit codes and JSON","text":""},{"location":"tutorial/chapter3-walkthrough/#exit-codes","title":"Exit codes","text":"<p><code>pynmms ask</code> uses semantic exit codes following the <code>grep</code>/<code>diff</code> convention:</p> Exit code Meaning 0 Derivable 1 Error 2 Not derivable <p>Use this in shell scripts:</p> <pre><code>if pynmms ask -b toyT.json -q \"p =&gt; q\"; then\n    echo \"p entails q\"\nelse\n    echo \"p does not entail q\"\nfi\n</code></pre>"},{"location":"tutorial/chapter3-walkthrough/#json-output","title":"JSON output","text":"<p>Use <code>--json</code> for machine-readable output:</p> <pre><code>$ pynmms ask -b toyT.json --json \"p =&gt; q\"\n{\"status\":\"DERIVABLE\",\"sequent\":{\"antecedent\":[\"p\"],\"consequent\":[\"q\"]},\"depth_reached\":0,\"cache_hits\":0}\n</code></pre> <p>Pipe to <code>jq</code>:</p> <pre><code>$ pynmms ask -b toyT.json --json \"p =&gt; q\" | jq .status\n\"DERIVABLE\"\n</code></pre>"},{"location":"tutorial/chapter3-walkthrough/#batch-queries","title":"Batch queries","text":"<p>Query multiple sequents at once:</p> <pre><code># queries.txt\np =&gt; q\np, r =&gt; q\n=&gt; p -&gt; q\n=&gt; ~(s &amp; t)\np =&gt; v\n</code></pre> <pre><code>$ pynmms ask -b toyT.json --json --batch queries.txt\n{\"status\":\"DERIVABLE\",\"sequent\":{\"antecedent\":[\"p\"],\"consequent\":[\"q\"]},\"depth_reached\":0,\"cache_hits\":0}\n{\"status\":\"NOT_DERIVABLE\",\"sequent\":{\"antecedent\":[\"p\",\"r\"],\"consequent\":[\"q\"]},\"depth_reached\":1,\"cache_hits\":0}\n{\"status\":\"DERIVABLE\",\"sequent\":{\"antecedent\":[],\"consequent\":[\"p -&gt; q\"]},\"depth_reached\":1,\"cache_hits\":0}\n{\"status\":\"DERIVABLE\",\"sequent\":{\"antecedent\":[],\"consequent\":[\"~(s &amp; t)\"]},\"depth_reached\":2,\"cache_hits\":0}\n{\"status\":\"NOT_DERIVABLE\",\"sequent\":{\"antecedent\":[\"p\"],\"consequent\":[\"v\"]},\"depth_reached\":1,\"cache_hits\":0}\n</code></pre> <p>The exit code reflects the aggregate: 0 if all derivable, 2 if any not derivable, 1 on error.</p>"},{"location":"tutorial/cli-usage/","title":"CLI Usage","text":""},{"location":"tutorial/cli-usage/#overview","title":"Overview","text":"<p>pyNMMS provides the <code>pynmms</code> command with three subcommands:</p> <pre><code>pynmms tell   # Add atoms or consequences to a base\npynmms ask    # Query derivability\npynmms repl   # Interactive REPL\n</code></pre>"},{"location":"tutorial/cli-usage/#notation","title":"Notation","text":"<p>Notational conventions.</p> <ul> <li>A, B, ... range over sentences of the object language.</li> <li>p, q, r, ... range over atomic sentences.</li> <li>\u0393, \u0394 range over finite sets of sentences.</li> </ul> <p>The two turnstiles:</p> <ul> <li>\u0393 <code>|~</code> \u0394 \u2014 a base consequence. The <code>tell</code> command adds the pair (\u0393, \u0394) to the base consequence relation |~<sub>B</sub>. In the theory, |~<sub>B</sub> is a given relation (Definition 1, Ch. 3); in the tool it is built incrementally.</li> <li>\u0393 <code>=&gt;</code> \u0394 \u2014 a sequent. The <code>ask</code> command tests whether the sequent \u0393 \u21d2 \u0394 is derivable, i.e., whether there exists a proof tree whose leaves are all axioms of the base.</li> </ul> <p>Note: <code>|~</code> is input (asserting into the base); <code>=&gt;</code> is query (testing derivability from the base). Both \u0393 and \u0394 may be empty.</p>"},{"location":"tutorial/cli-usage/#propositional-object-language","title":"Propositional Object Language","text":"<p>The propositional object language is defined by the following unambiguous grammar:</p> <pre><code>sentence   ::=  impl\nimpl       ::=  disj ( '-&gt;' disj )*            (* right-associative *)\ndisj       ::=  conj ( '|' conj )*             (* left-associative *)\nconj       ::=  unary ( '&amp;' unary )*           (* left-associative *)\nunary      ::=  '~' unary | atom | '(' sentence ')'\natom       ::=  IDENTIFIER\n</code></pre> <p>Where <code>IDENTIFIER</code> is any non-empty string of letters, digits, and underscores beginning with a letter or underscore. Precedence (tightest to loosest): <code>~</code>, <code>&amp;</code>, <code>|</code>, <code>-&gt;</code>.</p> <p>Connective glossary:</p> Symbol Name Arity <code>~</code> negation prefix unary <code>&amp;</code> conjunction binary, left-associative | disjunction binary, left-associative <code>-&gt;</code> conditional (implication) binary, right-associative"},{"location":"tutorial/cli-usage/#the-nmms_onto-object-language","title":"The NMMS_Onto Object Language","text":"<p>The <code>--onto</code> flag enables NMMS_Onto, an ontology engineering extension of the propositional NMMS object language with concept and role assertions. The vocabulary is borrowed from W3C RDFS and OWL for familiarity; the semantics are those of NMMS (exact-match defeasibility, no weakening, no transitivity).</p> <p>Atoms. In propositional NMMS, atoms are bare identifiers. In NMMS_Onto, atoms are ground atomic formulas:</p> Form Name Example C(a) concept assertion <code>Happy(alice)</code> R(a, b) role assertion <code>hasChild(alice,bob)</code> <p>Bare propositional letters are not valid in NMMS_Onto.</p> <p>Grammar. The NMMS_Onto grammar replaces the propositional <code>atom</code> production:</p> <pre><code>atom       ::=  CONCEPT '(' INDIVIDUAL ')'                  (* concept assertion *)\n             |  ROLE '(' INDIVIDUAL ',' INDIVIDUAL ')'      (* role assertion *)\nsentence   ::=  ...                                          (* all propositional forms *)\n</code></pre> <p>Ontology Schemas. In ontology mode, the <code>tell</code> command also supports schema registration. Schemas are macros that generate families of ordinary base axioms:</p> Schema CLI syntax Generated axiom pattern <code>subClassOf</code> <code>schema subClassOf C D</code> {C(x)} |~ {D(x)} for any x <code>range</code> <code>schema range R C</code> {R(x,y)} |~ {C(y)} for any x,y <code>domain</code> <code>schema domain R C</code> {R(x,y)} |~ {C(x)} for any x,y <code>subPropertyOf</code> <code>schema subPropertyOf R S</code> {R(x,y)} |~ {S(x,y)} for any x,y <code>disjointWith</code> <code>schema disjointWith C D</code> {C(x), D(x)} |~ {} for any x <code>disjointProperties</code> <code>schema disjointProperties R S</code> {R(x,y), S(x,y)} |~ {} for any x,y"},{"location":"tutorial/cli-usage/#pynmms-tell","title":"<code>pynmms tell</code>","text":"<p>Add atoms or consequences to a JSON base file.</p> <pre><code># Create a new base and add a consequence\npynmms tell -b base.json --create \"A |~ B\"\n\n# Add more consequences (base file must exist)\npynmms tell -b base.json \"B |~ C\"\n\n# Add atoms\npynmms tell -b base.json \"atom X\"\n\n# Add atoms with annotations\npynmms tell -b base.json 'atom p \"Tara is human\"'\n\n# Empty consequent (incompatibility)\npynmms tell -b base.json \"s, t |~\"\n\n# Empty antecedent (unconditional assertion)\npynmms tell -b base.json \"|~ p\"\n</code></pre>"},{"location":"tutorial/cli-usage/#syntax","title":"Syntax","text":"<ul> <li>Consequence: <code>A |~ B</code> or <code>A, B |~ C, D</code> (comma-separated)</li> <li>Incompatibility: <code>A, B |~</code> (empty consequent)</li> <li>Unconditional assertion: <code>|~ A</code> (empty antecedent)</li> <li>Atom: <code>atom X</code></li> <li>Atom with annotation: <code>atom X \"description\"</code></li> </ul>"},{"location":"tutorial/cli-usage/#options","title":"Options","text":"Flag Description <code>-b</code>, <code>--base</code> Path to JSON base file (required) <code>--create</code> Create the base file if missing <code>--onto</code> Use ontology mode (concept/role assertions with schema-level macros) <code>--json</code> Output as JSON (pipe-friendly) <code>-q</code>, <code>--quiet</code> Suppress output; rely on exit code <code>--batch FILE</code> Read statements from FILE (use <code>-</code> for stdin)"},{"location":"tutorial/cli-usage/#pynmms-ask","title":"<code>pynmms ask</code>","text":"<p>Query whether a sequent is derivable.</p> <pre><code>pynmms ask -b base.json \"A =&gt; B\"\n# Output: DERIVABLE\n\npynmms ask -b base.json \"A =&gt; C\"\n# Output: NOT DERIVABLE\n</code></pre>"},{"location":"tutorial/cli-usage/#exit-codes","title":"Exit codes","text":"<p>Following the <code>grep</code>/<code>diff</code>/<code>cmp</code> convention:</p> Exit code Meaning 0 Derivable 1 Error 2 Not derivable"},{"location":"tutorial/cli-usage/#options_1","title":"Options","text":"Flag Description <code>-b</code>, <code>--base</code> Path to JSON base file (required) <code>--trace</code> Print the proof trace <code>--max-depth N</code> Set the maximum proof depth (default: 25) <code>--onto</code> Use ontology mode (concept/role assertions with schema-level macros) <code>--json</code> Output as JSON (pipe-friendly) <code>-q</code>, <code>--quiet</code> Suppress output; rely on exit code <code>--batch FILE</code> Read sequents from FILE (use <code>-</code> for stdin)"},{"location":"tutorial/cli-usage/#json-output","title":"JSON output","text":"<pre><code>pynmms ask -b base.json --json \"A =&gt; B\"\n# Output: {\"status\":\"DERIVABLE\",\"sequent\":{\"antecedent\":[\"A\"],\"consequent\":[\"B\"]},\"depth_reached\":0,\"cache_hits\":0}\n</code></pre> <p>With <code>--trace</code>, adds a <code>\"trace\"</code> array.</p>"},{"location":"tutorial/cli-usage/#stdin-input","title":"Stdin input","text":"<pre><code>echo \"A =&gt; B\" | pynmms ask -b base.json -\n</code></pre>"},{"location":"tutorial/cli-usage/#batch-mode","title":"Batch mode","text":"<pre><code>pynmms ask -b base.json --batch queries.txt\npynmms ask -b base.json --json --batch queries.txt\ncat queries.txt | pynmms ask -b base.json --batch -\n</code></pre> <pre><code>pynmms ask -b base.json --trace \"=&gt; A -&gt; B\"\n# Output:\n# DERIVABLE\n#\n# Proof trace:\n#   [R\u2192] on A -&gt; B\n#     AXIOM: A =&gt; B\n#\n# Depth reached: 1\n# Cache hits: 0\n</code></pre>"},{"location":"tutorial/cli-usage/#pynmms-repl","title":"<code>pynmms repl</code>","text":"<p>Interactive REPL for exploring reason relations.</p> <pre><code>pynmms repl\npynmms repl -b base.json  # Load existing base\n</code></pre>"},{"location":"tutorial/cli-usage/#repl-commands","title":"REPL Commands","text":"Command Description tell A |~ B Add a consequence tell A, B |~ Add incompatibility (empty consequent) tell |~ A Add unconditional assertion (empty antecedent) tell atom A Add an atom tell atom A \"desc\" Add an atom with annotation ask A =&gt; B Query derivability show Display the current base (with annotations) trace on/off Toggle proof trace display save &lt;file&gt; Save base to JSON load &lt;file&gt; Load base from JSON help Show available commands quit Exit the REPL"},{"location":"tutorial/cli-usage/#example-session","title":"Example Session","text":"<pre><code>$ pynmms repl\nStarting with empty base.\npyNMMS REPL. Type 'help' for commands.\n\npynmms&gt; tell atom p \"Tara is human\"\nAdded atom: p -- Tara is human\npynmms&gt; tell atom q \"Tara's body temp is 37C\"\nAdded atom: q -- Tara's body temp is 37C\npynmms&gt; tell p |~ q\nAdded: {'p'} |~ {'q'}\npynmms&gt; tell s, t |~\nAdded: set() |~ set()\npynmms&gt; ask p =&gt; q\nDERIVABLE\npynmms&gt; ask p, r =&gt; q\nNOT DERIVABLE\npynmms&gt; show\nLanguage (4 atoms):\n  p -- Tara is human\n  q -- Tara's body temp is 37C\n  s\n  t\nConsequences (2):\n  {'p'} |~ {'q'}\n  {'s', 't'} |~ set()\npynmms&gt; save mybase.json\nSaved to mybase.json\npynmms&gt; quit\n</code></pre>"},{"location":"tutorial/cli-usage/#batch-files","title":"Batch files","text":""},{"location":"tutorial/cli-usage/#tell-batch-format","title":"Tell batch format","text":"<p>One statement per line. Blank lines and <code>#</code> comments are skipped:</p> <pre><code># mybase.base\natom p \"Tara is human\"\natom q \"Tara's body temp is 37C\"\np |~ q\ns, t |~\n</code></pre> <pre><code>pynmms tell -b base.json --create --batch mybase.base\n</code></pre>"},{"location":"tutorial/cli-usage/#ontology-batch-format","title":"Ontology batch format","text":"<p>With <code>--onto</code>, batch files also support <code>schema</code> lines (with optional quoted annotations):</p> <pre><code>atom Man(socrates) \"Socrates is a man\"\natom hasChild(alice,bob)\nMan(socrates) |~ Mortal(socrates)\nschema subClassOf Man Mortal \"All men are mortal\"\nschema range hasChild Person \"Children are persons\"\nschema domain hasChild Parent \"Parents have children\"\nschema subPropertyOf hasChild hasDescendant \"Children are descendants\"\nschema disjointWith Alive Dead \"Life and death are incompatible\"\nschema disjointProperties employs isEmployedBy \"Cannot both employ and be employed by\"\n</code></pre> <pre><code>pynmms tell -b onto_base.json --create --onto --batch onto_base.base\n</code></pre>"},{"location":"tutorial/cli-usage/#ask-batch-format","title":"Ask batch format","text":"<p>One sequent per line:</p> <pre><code># queries.txt\nA =&gt; B\nA, B =&gt; C\n=&gt; A -&gt; B\n</code></pre> <pre><code>pynmms ask -b base.json --batch queries.txt\npynmms ask -b base.json --json --batch queries.txt  # JSONL output\n</code></pre>"},{"location":"tutorial/concepts/","title":"Key Concepts","text":""},{"location":"tutorial/concepts/#material-bases","title":"Material Bases","text":"<p>A material base B =  consists of: <ul> <li>L_B: An atomic language \u2014 a set of atomic sentence strings (e.g., <code>\"rain\"</code>, <code>\"wet_ground\"</code>)</li> <li>|~_B: A base consequence relation \u2014 a set of sequents (Gamma, Delta) where Gamma and Delta are sets of atomic sentences</li> </ul> <p>The base encodes defeasible material inferences: reasoning patterns that hold in normal circumstances but can be overridden by additional information.</p>"},{"location":"tutorial/concepts/#containment-axiom","title":"Containment Axiom","text":"<p>Every material base automatically satisfies Containment: if Gamma and Delta share any element (Gamma \u2229 Delta \u2260 \u2205), then Gamma |~_B Delta. This is the analogue of the identity axiom in classical logic.</p>"},{"location":"tutorial/concepts/#exact-match-no-weakening","title":"Exact Match (No Weakening)","text":"<p>Base consequences require exact syntactic match. If the base contains <code>{A} |~ {B}</code>, then <code>{A, C} |~ {B}</code> is not an axiom. This is what makes the system nonmonotonic \u2014 extra premises can defeat inferences.</p>"},{"location":"tutorial/concepts/#sequents","title":"Sequents","text":"<p>A sequent Gamma =&gt; Delta represents a reason relation: the sentences in Gamma (the antecedent) provide reason for at least one of the sentences in Delta (the succedent).</p> <ul> <li>Multi-succedent: Delta can contain multiple sentences. <code>Gamma =&gt; A, B</code> means \"Gamma provides reason for A-or-B.\"</li> <li>Empty antecedent: <code>=&gt; A</code> means A is unconditionally assertable.</li> <li>Empty succedent: <code>A =&gt;</code> means A is incoherent (leads to nothing).</li> </ul>"},{"location":"tutorial/concepts/#nonmonotonicity","title":"Nonmonotonicity","text":"<p>In NMMS, adding premises can defeat inferences. If <code>{rain} |~ {wet_ground}</code> but the base has no consequence from <code>{rain, covered}</code>, then:</p> <ul> <li><code>rain =&gt; wet_ground</code> is derivable</li> <li><code>rain, covered =&gt; wet_ground</code> is not derivable</li> </ul> <p>This models the everyday pattern: rain normally makes the ground wet, but if the ground is covered, the inference is defeated.</p>"},{"location":"tutorial/concepts/#nontransitivity","title":"Nontransitivity","text":"<p>NMMS also lacks Mixed-Cut (the structural rule for transitivity). Even if <code>A |~ B</code> and <code>B |~ C</code>, it does not follow that <code>A |~ C</code>. Each inference step must be independently justified by the base.</p>"},{"location":"tutorial/concepts/#supraclassicality","title":"Supraclassicality","text":"<p>Despite lacking Weakening and Mixed-Cut, NMMS is supraclassical: all classically valid sequents are derivable. The law of excluded middle (<code>=&gt; A | ~A</code>), double negation elimination (<code>~~A =&gt; A</code>), and all classical tautologies hold.</p>"},{"location":"tutorial/concepts/#explicitation-conditions","title":"Explicitation Conditions","text":"<p>The logical connectives \"make explicit\" reason relations through these biconditionals:</p> <ul> <li>DD (Deduction-Detachment): <code>Gamma |~ A -&gt; B, Delta</code> iff <code>Gamma, A |~ B, Delta</code></li> <li>II (Incoherence-Incompatibility): <code>Gamma |~ ~A, Delta</code> iff <code>Gamma, A |~ Delta</code></li> <li>AA (Antecedent-Adjunction): <code>Gamma, A &amp; B |~ Delta</code> iff <code>Gamma, A, B |~ Delta</code></li> <li>SS (Succedent-Summation): <code>Gamma |~ A | B, Delta</code> iff <code>Gamma |~ A, B, Delta</code></li> </ul>"},{"location":"tutorial/material-bases/","title":"Material Bases","text":""},{"location":"tutorial/material-bases/#creating-a-base","title":"Creating a Base","text":""},{"location":"tutorial/material-bases/#via-python-api","title":"Via Python API","text":"<pre><code>from pynmms import MaterialBase\n\n# From constructor\nbase = MaterialBase(\n    language={\"A\", \"B\", \"C\"},\n    consequences={\n        (frozenset({\"A\"}), frozenset({\"B\"})),\n        (frozenset({\"B\"}), frozenset({\"C\"})),\n    },\n)\n\n# Incrementally\nbase = MaterialBase()\nbase.add_atom(\"A\")\nbase.add_atom(\"B\")\nbase.add_consequence(frozenset({\"A\"}), frozenset({\"B\"}))\n</code></pre>"},{"location":"tutorial/material-bases/#via-cli","title":"Via CLI","text":"<pre><code>pynmms tell -b mybase.json --create \"atom A\"\npynmms tell -b mybase.json \"atom B\"\npynmms tell -b mybase.json \"A |~ B\"\n</code></pre>"},{"location":"tutorial/material-bases/#checking-axioms","title":"Checking Axioms","text":"<p>The <code>is_axiom</code> method checks whether a sequent is an axiom of the base:</p> <pre><code>base.is_axiom(frozenset({\"A\"}), frozenset({\"A\"}))  # True (Containment)\nbase.is_axiom(frozenset({\"A\"}), frozenset({\"B\"}))  # True (base consequence)\nbase.is_axiom(frozenset({\"A\", \"X\"}), frozenset({\"B\"}))  # False (no weakening)\n</code></pre>"},{"location":"tutorial/material-bases/#serialization","title":"Serialization","text":"<p>Bases can be saved to and loaded from JSON:</p> <pre><code># Save\nbase.to_file(\"mybase.json\")\n\n# Load\nbase = MaterialBase.from_file(\"mybase.json\")\n\n# Dict round-trip\ndata = base.to_dict()\nbase = MaterialBase.from_dict(data)\n</code></pre>"},{"location":"tutorial/material-bases/#json-format","title":"JSON Format","text":"<pre><code>{\n  \"language\": [\"A\", \"B\", \"C\"],\n  \"consequences\": [\n    {\"antecedent\": [\"A\"], \"consequent\": [\"B\"]},\n    {\"antecedent\": [\"B\"], \"consequent\": [\"C\"]}\n  ]\n}\n</code></pre>"},{"location":"tutorial/material-bases/#validation","title":"Validation","text":"<p>The base enforces that all sentences are atomic:</p> <pre><code># This raises ValueError:\nMaterialBase(language={\"~A\"})  # Negation is not atomic\nMaterialBase(consequences={(frozenset({\"A -&gt; B\"}), frozenset({\"C\"}))})  # Implication is not atomic\n</code></pre>"},{"location":"tutorial/onto-tutorial/","title":"Ontology Extension Tutorial","text":"<p>This tutorial introduces the NMMS_Onto ontology engineering extension of pyNMMS, which provides schema-level macros for material inferential commitments and incompatibilities within the NMMS sequent calculus. Ontology schemas (subClassOf, range, domain, subPropertyOf, disjointWith, disjointProperties) are encoded as lazy axiom schemas in the material base, evaluated at query time with exact match to preserve nonmonotonicity.</p> <p>The vocabulary is borrowed from W3C RDFS and OWL for familiarity, but the semantics are those of NMMS -- exact-match defeasibility, no weakening, no transitivity. These schemas add no new reasoning capabilities; they are macros that generate ordinary base axioms.</p> <p>The ontology extension lives in the <code>pynmms.onto</code> subpackage and uses the standard <code>NMMSReasoner</code> for proof search -- no special reasoner is required.</p>"},{"location":"tutorial/onto-tutorial/#1-building-an-ontology-material-base","title":"1. Building an Ontology Material Base","text":"<p>An <code>OntoMaterialBase</code> extends the propositional <code>MaterialBase</code> with ontology-style vocabulary tracking. Atoms in an ontology base are ground atomic formulas: concept assertions <code>C(a)</code> and role assertions <code>R(a,b)</code>. Bare propositional letters are not permitted.</p>"},{"location":"tutorial/onto-tutorial/#abox-concept-and-role-assertions","title":"ABox: Concept and Role Assertions","text":"<p>The ABox (assertional box) is built from concept assertions and role assertions that describe particular individuals:</p> <pre><code>from pynmms.onto import OntoMaterialBase\n\n# Create a base with concept and role assertions\nbase = OntoMaterialBase(\n    language={\"Man(socrates)\", \"hasChild(alice,bob)\"}\n)\n\n# The base automatically tracks vocabulary\nprint(base.individuals)  # frozenset({'socrates', 'alice', 'bob'})\nprint(base.concepts)     # frozenset({'Man'})\nprint(base.roles)        # frozenset({'hasChild'})\n</code></pre> <p>You can also add atoms incrementally:</p> <pre><code>base = OntoMaterialBase()\n\nbase.add_atom(\"Man(socrates)\")\nbase.add_atom(\"Greek(socrates)\")\nbase.add_atom(\"hasChild(alice,bob)\")\nbase.add_atom(\"Doctor(bob)\")\n</code></pre>"},{"location":"tutorial/onto-tutorial/#base-consequences","title":"Base Consequences","text":"<p>Explicit base consequences (material inferences among atomic sentences) can be added at construction time or later:</p> <pre><code># At construction time\nbase = OntoMaterialBase(\n    language={\"Man(socrates)\", \"Mortal(socrates)\"},\n    consequences={\n        (frozenset({\"Man(socrates)\"}), frozenset({\"Mortal(socrates)\"})),\n    },\n)\n\n# Or incrementally\nbase.add_consequence(\n    frozenset({\"Greek(socrates)\"}),\n    frozenset({\"Philosopher(socrates)\"}),\n)\n</code></pre> <p>These are exact-match axioms with no weakening -- adding extra premises will defeat the inference, which is the hallmark of nonmonotonic reasoning.</p>"},{"location":"tutorial/onto-tutorial/#2-adding-ontology-schemas-tbox","title":"2. Adding Ontology Schemas (TBox)","text":"<p>The TBox (terminological box) consists of ontology schema macros that generate families of axiom instances via lazy evaluation. Six schema types are supported:</p>"},{"location":"tutorial/onto-tutorial/#subclassof","title":"subClassOf","text":"<p>Registers a subsumption relationship between concepts. For any individual x, <code>{C(x)} |~ {D(x)}</code>:</p> <pre><code>base = OntoMaterialBase(language={\"Man(socrates)\"})\n\n# Man is a subclass of Mortal\nbase.register_subclass(\"Man\", \"Mortal\")\n\n# This makes {Man(socrates)} |~ {Mortal(socrates)} an axiom,\n# and likewise for any other individual that appears in the base.\n</code></pre>"},{"location":"tutorial/onto-tutorial/#range","title":"range","text":"<p>Registers a range constraint on a role. For any x, y, <code>{R(x,y)} |~ {C(y)}</code>:</p> <pre><code>base = OntoMaterialBase(language={\"hasChild(alice,bob)\"})\n\n# The range of hasChild is Person\nbase.register_range(\"hasChild\", \"Person\")\n\n# This makes {hasChild(alice,bob)} |~ {Person(bob)} an axiom.\n# The concept is applied to the second argument (the object).\n</code></pre>"},{"location":"tutorial/onto-tutorial/#domain","title":"domain","text":"<p>Registers a domain constraint on a role. For any x, y, <code>{R(x,y)} |~ {C(x)}</code>:</p> <pre><code>base = OntoMaterialBase(language={\"hasChild(alice,bob)\"})\n\n# The domain of hasChild is Parent\nbase.register_domain(\"hasChild\", \"Parent\")\n\n# This makes {hasChild(alice,bob)} |~ {Parent(alice)} an axiom.\n# The concept is applied to the first argument (the subject).\n</code></pre>"},{"location":"tutorial/onto-tutorial/#subpropertyof","title":"subPropertyOf","text":"<p>Registers a sub-property relationship between roles. For any x, y, <code>{R(x,y)} |~ {S(x,y)}</code>:</p> <pre><code>base = OntoMaterialBase(language={\"hasChild(alice,bob)\"})\n\n# hasChild is a sub-property of hasDescendant\nbase.register_subproperty(\"hasChild\", \"hasDescendant\")\n\n# This makes {hasChild(alice,bob)} |~ {hasDescendant(alice,bob)} an axiom.\n</code></pre>"},{"location":"tutorial/onto-tutorial/#disjointwith","title":"disjointWith","text":"<p>Registers an incompatibility between concepts. For any individual x, <code>{C(x), D(x)} |~ {}</code>:</p> <pre><code>base = OntoMaterialBase(language={\"Alive(socrates)\", \"Dead(socrates)\"})\n\n# Alive and Dead are incompatible concepts\nbase.register_disjoint_concepts(\"Alive\", \"Dead\")\n\n# This makes {Alive(socrates), Dead(socrates)} |~ {} an axiom.\n# The empty consequent means the pair of premises is incoherent.\n</code></pre> <p>Incompatibility is foundational in Brandom's framework -- it is prior to negation, not derived from it. The <code>disjointWith</code> schema directly encodes material incompatibility between concepts.</p>"},{"location":"tutorial/onto-tutorial/#disjointproperties","title":"disjointProperties","text":"<p>Registers an incompatibility between roles. For any individuals x, y, <code>{R(x,y), S(x,y)} |~ {}</code>:</p> <pre><code>base = OntoMaterialBase(language={\"employs(alice,bob)\", \"isEmployedBy(alice,bob)\"})\n\n# employs and isEmployedBy are incompatible for the same pair\nbase.register_disjoint_properties(\"employs\", \"isEmployedBy\")\n\n# This makes {employs(alice,bob), isEmployedBy(alice,bob)} |~ {} an axiom.\n</code></pre>"},{"location":"tutorial/onto-tutorial/#annotations","title":"Annotations","text":"<p>All schema registration methods accept an optional <code>annotation</code> parameter for documentation:</p> <pre><code>base.register_subclass(\"Man\", \"Mortal\", annotation=\"All men are mortal\")\nbase.register_range(\"hasChild\", \"Person\", annotation=\"Children are persons\")\nbase.register_disjoint_concepts(\"Alive\", \"Dead\", annotation=\"Life and death are incompatible\")\n</code></pre>"},{"location":"tutorial/onto-tutorial/#complete-tbox-example","title":"Complete TBox Example","text":"<pre><code>from pynmms.onto import OntoMaterialBase\n\nbase = OntoMaterialBase(\n    language={\n        \"Man(socrates)\",\n        \"hasChild(alice,bob)\",\n        \"Doctor(bob)\",\n        \"Alive(socrates)\",\n    }\n)\n\nbase.register_subclass(\"Man\", \"Mortal\")\nbase.register_range(\"hasChild\", \"Person\")\nbase.register_domain(\"hasChild\", \"Parent\")\nbase.register_subproperty(\"hasChild\", \"hasDescendant\")\nbase.register_disjoint_concepts(\"Alive\", \"Dead\")\nbase.register_disjoint_properties(\"employs\", \"isEmployedBy\")\n</code></pre>"},{"location":"tutorial/onto-tutorial/#lazy-evaluation","title":"Lazy Evaluation","text":"<p>Schemas are not eagerly grounded over all known individuals. Instead, they are checked lazily during axiom evaluation: when the reasoner encounters a candidate sequent <code>{C(a)} =&gt; {D(a)}</code>, it tests whether any registered schema matches. This avoids combinatorial blowup and preserves the exact-match semantics needed for nonmonotonicity.</p>"},{"location":"tutorial/onto-tutorial/#3-querying-with-nmmsreasoner","title":"3. Querying with NMMSReasoner","text":"<p>The standard <code>NMMSReasoner</code> works transparently with <code>OntoMaterialBase</code> because ontology schemas are evaluated at the axiom level (via the overridden <code>is_axiom</code> method). No special reasoner class is needed.</p> <pre><code>from pynmms.onto import OntoMaterialBase\nfrom pynmms.reasoner import NMMSReasoner\n\n# Build the base\nbase = OntoMaterialBase(language={\"Man(socrates)\"})\nbase.register_subclass(\"Man\", \"Mortal\")\n\n# Create a standard reasoner\nr = NMMSReasoner(base, max_depth=15)\n\n# Query: Man(socrates) =&gt; Mortal(socrates)?\nresult = r.derives(\n    frozenset({\"Man(socrates)\"}),\n    frozenset({\"Mortal(socrates)\"})\n)\nprint(result.derivable)  # True\n\n# Convenience method\nprint(r.query(\n    frozenset({\"Man(socrates)\"}),\n    frozenset({\"Mortal(socrates)\"})\n))  # True\n</code></pre>"},{"location":"tutorial/onto-tutorial/#range-and-domain-queries","title":"Range and Domain Queries","text":"<pre><code>base = OntoMaterialBase(language={\"hasChild(alice,bob)\"})\nbase.register_range(\"hasChild\", \"Person\")\nbase.register_domain(\"hasChild\", \"Parent\")\n\nr = NMMSReasoner(base, max_depth=15)\n\n# Range: hasChild(alice,bob) =&gt; Person(bob)?\nprint(r.query(\n    frozenset({\"hasChild(alice,bob)\"}),\n    frozenset({\"Person(bob)\"})\n))  # True\n\n# Domain: hasChild(alice,bob) =&gt; Parent(alice)?\nprint(r.query(\n    frozenset({\"hasChild(alice,bob)\"}),\n    frozenset({\"Parent(alice)\"})\n))  # True\n</code></pre>"},{"location":"tutorial/onto-tutorial/#subproperty-queries","title":"SubProperty Queries","text":"<pre><code>base = OntoMaterialBase(language={\"hasChild(alice,bob)\"})\nbase.register_subproperty(\"hasChild\", \"hasDescendant\")\n\nr = NMMSReasoner(base, max_depth=15)\n\n# hasChild(alice,bob) =&gt; hasDescendant(alice,bob)?\nprint(r.query(\n    frozenset({\"hasChild(alice,bob)\"}),\n    frozenset({\"hasDescendant(alice,bob)\"})\n))  # True\n</code></pre>"},{"location":"tutorial/onto-tutorial/#incompatibility-queries","title":"Incompatibility Queries","text":"<pre><code>base = OntoMaterialBase(language={\"Alive(socrates)\", \"Dead(socrates)\"})\nbase.register_disjoint_concepts(\"Alive\", \"Dead\")\n\nr = NMMSReasoner(base, max_depth=15)\n\n# Incompatibility: Alive(socrates), Dead(socrates) =&gt; {} (empty consequent)?\nprint(r.query(\n    frozenset({\"Alive(socrates)\", \"Dead(socrates)\"}),\n    frozenset()\n))  # True\n\n# With extra premise, the incompatibility is defeated\nprint(r.query(\n    frozenset({\"Alive(socrates)\", \"Dead(socrates)\", \"Zombie(socrates)\"}),\n    frozenset()\n))  # False\n</code></pre>"},{"location":"tutorial/onto-tutorial/#proof-traces","title":"Proof Traces","text":"<p>The <code>derives</code> method returns a <code>ProofResult</code> with a human-readable trace:</p> <pre><code>result = r.derives(\n    frozenset({\"Man(socrates)\"}),\n    frozenset({\"Mortal(socrates)\"})\n)\nfor line in result.trace:\n    print(line)\n# AXIOM: Man(socrates) =&gt; Mortal(socrates)\n</code></pre>"},{"location":"tutorial/onto-tutorial/#4-defeasibility","title":"4. Defeasibility","text":"<p>Because NMMS omits the structural rule of Weakening, ontology inferences are defeasible: adding extra premises can defeat an otherwise good inference.</p> <pre><code>from pynmms.onto import OntoMaterialBase\nfrom pynmms.reasoner import NMMSReasoner\n\nbase = OntoMaterialBase(language={\"Man(socrates)\"})\nbase.register_subclass(\"Man\", \"Mortal\")\n\nr = NMMSReasoner(base, max_depth=15)\n\n# The basic inference holds\nprint(r.query(\n    frozenset({\"Man(socrates)\"}),\n    frozenset({\"Mortal(socrates)\"})\n))  # True\n\n# Adding an extra premise defeats it -- nonmonotonicity!\nprint(r.query(\n    frozenset({\"Man(socrates)\", \"Divine(socrates)\"}),\n    frozenset({\"Mortal(socrates)\"})\n))  # False\n</code></pre> <p>The schema <code>{Man(x)} |~ {Mortal(x)}</code> is an exact-match axiom: it requires the antecedent to be exactly <code>{Man(socrates)}</code> and the consequent to be exactly <code>{Mortal(socrates)}</code>. The sequent <code>{Man(socrates), Divine(socrates)} =&gt; {Mortal(socrates)}</code> has an extra premise <code>Divine(socrates)</code>, so the schema does not fire. Without Weakening, there is no way to derive the strengthened sequent from the weaker one.</p> <p>This models a natural reasoning pattern: we normally infer that Socrates is mortal from his being a man, but learning that he is divine defeats that inference. In NMMS, the defeat is structural -- it follows from the absence of Weakening, not from any explicit exception mechanism.</p>"},{"location":"tutorial/onto-tutorial/#range-defeasibility","title":"Range Defeasibility","text":"<p>The same holds for range, domain, subPropertyOf, disjointWith, and disjointProperties schemas:</p> <pre><code>base = OntoMaterialBase(language={\"hasChild(alice,bob)\"})\nbase.register_range(\"hasChild\", \"Person\")\n\nr = NMMSReasoner(base, max_depth=15)\n\n# Range inference holds\nprint(r.query(\n    frozenset({\"hasChild(alice,bob)\"}),\n    frozenset({\"Person(bob)\"})\n))  # True\n\n# Extra premise defeats it\nprint(r.query(\n    frozenset({\"hasChild(alice,bob)\", \"Robot(bob)\"}),\n    frozenset({\"Person(bob)\"})\n))  # False\n</code></pre>"},{"location":"tutorial/onto-tutorial/#5-non-transitivity","title":"5. Non-transitivity","text":"<p>NMMS also omits the structural rule of Mixed-Cut (Transitivity). This means that chaining individually good inferences can yield a bad inference -- subClassOf chains do not automatically propagate.</p> <pre><code>from pynmms.onto import OntoMaterialBase\nfrom pynmms.reasoner import NMMSReasoner\n\nbase = OntoMaterialBase(language={\"Man(socrates)\"})\nbase.register_subclass(\"Man\", \"Mortal\")\nbase.register_subclass(\"Mortal\", \"Perishable\")\n\nr = NMMSReasoner(base, max_depth=15)\n\n# Each step holds individually\nprint(r.query(\n    frozenset({\"Man(socrates)\"}),\n    frozenset({\"Mortal(socrates)\"})\n))  # True\n\nprint(r.query(\n    frozenset({\"Mortal(socrates)\"}),\n    frozenset({\"Perishable(socrates)\"})\n))  # True\n\n# But the chain does NOT propagate\nprint(r.query(\n    frozenset({\"Man(socrates)\"}),\n    frozenset({\"Perishable(socrates)\"})\n))  # False\n</code></pre> <p>The sequent <code>{Man(socrates)} =&gt; {Perishable(socrates)}</code> is not derivable because:</p> <ol> <li>The subClassOf schema for Man/Mortal only fires on <code>{Man(x)} |~ {Mortal(x)}</code>.</li> <li>The subClassOf schema for Mortal/Perishable only fires on <code>{Mortal(x)} |~ {Perishable(x)}</code>.</li> <li>There is no Mixed-Cut rule to chain these two axioms.</li> </ol> <p>This is a feature, not a bug. In open reason relations, transitivity failure models situations where each inference step is individually good but their composition is not -- for example, \"penguins are birds\" and \"birds fly\" are individually good inferences, but \"penguins fly\" is not.</p> <p>If you want the transitive closure, you must explicitly add the composed consequence:</p> <pre><code>base.add_consequence(\n    frozenset({\"Man(socrates)\"}),\n    frozenset({\"Perishable(socrates)\"})\n)\n\n# Now the chain holds (as an explicit base consequence)\nprint(r.query(\n    frozenset({\"Man(socrates)\"}),\n    frozenset({\"Perishable(socrates)\"})\n))  # True\n</code></pre>"},{"location":"tutorial/onto-tutorial/#6-deduction-detachment-theorem-ddt","title":"6. Deduction-Detachment Theorem (DDT)","text":"<p>The DDT is a fundamental property of NMMS: a conditional <code>A -&gt; B</code> is derivable on the right exactly when <code>B</code> is derivable from <code>A</code>. More precisely:</p> <p>Gamma |~ A -&gt; B, Delta \u00a0\u00a0iff\u00a0\u00a0 Gamma, A |~ B, Delta</p> <p>This means ontology schema consequences can be expressed in conditional form. If <code>{Man(socrates)} |~ {Mortal(socrates)}</code> is an axiom, then the conditional <code>Man(socrates) -&gt; Mortal(socrates)</code> is derivable as a theorem:</p> <pre><code>from pynmms.onto import OntoMaterialBase\nfrom pynmms.reasoner import NMMSReasoner\n\nbase = OntoMaterialBase(language={\"Man(socrates)\"})\nbase.register_subclass(\"Man\", \"Mortal\")\n\nr = NMMSReasoner(base, max_depth=15)\n\n# The material inference holds\nprint(r.query(\n    frozenset({\"Man(socrates)\"}),\n    frozenset({\"Mortal(socrates)\"})\n))  # True\n\n# So the conditional form is derivable (DDT, left-to-right)\nprint(r.query(\n    frozenset(),\n    frozenset({\"Man(socrates) -&gt; Mortal(socrates)\"})\n))  # True\n</code></pre> <p>The proof works via the [R-&gt;] rule:</p> <pre><code>  To derive: {} =&gt; {Man(socrates) -&gt; Mortal(socrates)}\n  Apply [R-&gt;]: need {Man(socrates)} =&gt; {Mortal(socrates)}\n  This is an axiom (subClassOf schema).\n</code></pre> <p>DDT also interacts with defeasibility. Since the conditional form is a theorem (derivable from the empty antecedent), it holds without any premises. But the material inference <code>{Man(socrates)} |~ {Mortal(socrates)}</code> is defeasible -- adding extra premises defeats it. The conditional \"makes explicit\" the defeasible reason relation by encoding it as a logical constant that can appear in further inferences.</p>"},{"location":"tutorial/onto-tutorial/#7-using-commitmentstore","title":"7. Using CommitmentStore","text":"<p>The <code>CommitmentStore</code> provides a higher-level API for managing ontology assertions and schemas. It accumulates commitments and compiles them into an <code>OntoMaterialBase</code> on demand. Each schema commitment includes a <code>source</code> string for provenance tracking and selective retraction.</p>"},{"location":"tutorial/onto-tutorial/#building-commitments","title":"Building Commitments","text":"<pre><code>from pynmms.onto import OntoMaterialBase, CommitmentStore\nfrom pynmms.reasoner import NMMSReasoner\n\nstore = CommitmentStore()\n\n# Add ABox assertions\nstore.add_concept(\"Man\", \"socrates\")\nstore.add_concept(\"Greek\", \"socrates\")\nstore.add_role(\"hasChild\", \"alice\", \"bob\")\nstore.add_concept(\"Doctor\", \"bob\")\n\n# Add TBox schemas with source attribution\nstore.commit_subclass(\"ontology-v1\", \"Man\", \"Mortal\")\nstore.commit_range(\"ontology-v1\", \"hasChild\", \"Person\")\nstore.commit_domain(\"ontology-v1\", \"hasChild\", \"Parent\")\nstore.commit_subproperty(\"ontology-v1\", \"hasChild\", \"hasDescendant\")\nstore.commit_disjoint_concepts(\"ontology-v1\", \"Alive\", \"Dead\")\nstore.commit_disjoint_properties(\"ontology-v1\", \"employs\", \"isEmployedBy\")\n\n# Compile to a base and query\nbase = store.compile()\nr = NMMSReasoner(base, max_depth=15)\n\nprint(r.query(\n    frozenset({\"Man(socrates)\"}),\n    frozenset({\"Mortal(socrates)\"})\n))  # True\n\nprint(r.query(\n    frozenset({\"hasChild(alice,bob)\"}),\n    frozenset({\"Person(bob)\"})\n))  # True\n</code></pre>"},{"location":"tutorial/onto-tutorial/#describing-commitments","title":"Describing Commitments","text":"<p>The <code>describe()</code> method provides a human-readable summary:</p> <pre><code>print(store.describe())\n# Commitment Store:\n#   Assertions: 4\n#     Doctor(bob)\n#     Greek(socrates)\n#     Man(socrates)\n#     hasChild(alice,bob)\n#   Ontology Schemas: 6\n#     [ontology-v1] subClassOf: Man(x) |~ Mortal(x)\n#     [ontology-v1] range: hasChild(x,y) |~ Person(y)\n#     [ontology-v1] domain: hasChild(x,y) |~ Parent(x)\n#     [ontology-v1] subPropertyOf: hasChild(x,y) |~ hasDescendant(x,y)\n#     [ontology-v1] disjointWith: Alive(x), Dead(x) |~\n#     [ontology-v1] disjointProperties: employs(x,y), isEmployedBy(x,y) |~\n</code></pre>"},{"location":"tutorial/onto-tutorial/#adding-ground-defeasible-rules","title":"Adding Ground Defeasible Rules","text":"<p>Beyond ontology schemas, the <code>CommitmentStore</code> supports arbitrary ground defeasible rules:</p> <pre><code>store.commit_defeasible_rule(\n    \"domain-expert\",\n    frozenset({\"Doctor(bob)\"}),\n    frozenset({\"Educated(bob)\"}),\n)\n\nbase = store.compile()\nr = NMMSReasoner(base, max_depth=15)\n\nprint(r.query(\n    frozenset({\"Doctor(bob)\"}),\n    frozenset({\"Educated(bob)\"})\n))  # True\n</code></pre>"},{"location":"tutorial/onto-tutorial/#retracting-schemas","title":"Retracting Schemas","text":"<p>Schemas can be retracted by source:</p> <pre><code>store.retract_schema(\"ontology-v1\")\n\nbase = store.compile()\nr = NMMSReasoner(base, max_depth=15)\n\n# The subClassOf schema no longer fires\nprint(r.query(\n    frozenset({\"Man(socrates)\"}),\n    frozenset({\"Mortal(socrates)\"})\n))  # False\n</code></pre>"},{"location":"tutorial/onto-tutorial/#caching","title":"Caching","text":"<p>The <code>compile()</code> method caches the result. Any mutation (adding assertions, committing schemas, retracting) invalidates the cache so the next <code>compile()</code> call rebuilds the base.</p>"},{"location":"tutorial/onto-tutorial/#8-cli-usage-with-onto","title":"8. CLI Usage with <code>--onto</code>","text":"<p>The <code>--onto</code> flag on the <code>tell</code>, <code>ask</code>, and <code>repl</code> subcommands activates ontology mode. In this mode, atoms must be concept assertions <code>C(a)</code> or role assertions <code>R(a,b)</code>.</p>"},{"location":"tutorial/onto-tutorial/#pynmms-tell-onto","title":"<code>pynmms tell --onto</code>","text":"<pre><code># Create a new ontology base with an atom\npynmms tell -b onto_base.json --create --onto \"atom Man(socrates)\"\n\n# Add more atoms\npynmms tell -b onto_base.json --onto \"atom hasChild(alice,bob)\"\npynmms tell -b onto_base.json --onto \"atom Doctor(bob)\"\n\n# Add atoms with annotations\npynmms tell -b onto_base.json --onto 'atom Man(socrates) \"Socrates is a man\"'\n\n# Add a base consequence\npynmms tell -b onto_base.json --onto \"Man(socrates) |~ Greek(socrates)\"\n\n# Add incompatibility (empty consequent)\npynmms tell -b onto_base.json --onto \"Alive(socrates), Dead(socrates) |~\"\n\n# Add theorem (empty antecedent)\npynmms tell -b onto_base.json --onto \"|~ Exists(socrates)\"\n</code></pre>"},{"location":"tutorial/onto-tutorial/#pynmms-ask-onto","title":"<code>pynmms ask --onto</code>","text":"<pre><code># Query derivability\npynmms ask -b onto_base.json --onto \"Man(socrates) =&gt; Greek(socrates)\"\n# Output: DERIVABLE\n\n# JSON output\npynmms ask -b onto_base.json --onto --json \"Man(socrates) =&gt; Greek(socrates)\"\n\n# Quiet mode (exit code only)\npynmms ask -b onto_base.json --onto -q \"Man(socrates) =&gt; Greek(socrates)\"\necho $?  # 0 = derivable, 2 = not derivable\n\n# Proof trace\npynmms ask -b onto_base.json --onto --trace \"Man(socrates) =&gt; Greek(socrates)\"\n</code></pre>"},{"location":"tutorial/onto-tutorial/#pynmms-repl-onto","title":"<code>pynmms repl --onto</code>","text":"<pre><code>pynmms repl --onto\npynmms repl --onto -b onto_base.json\n</code></pre>"},{"location":"tutorial/onto-tutorial/#batch-mode","title":"Batch Mode","text":"<p>Batch files support <code>schema</code> lines in ontology mode:</p> <pre><code># onto_base.txt\natom Man(socrates) \"Socrates is a man\"\natom hasChild(alice,bob)\natom Doctor(bob)\nMan(socrates) |~ Greek(socrates)\nschema subClassOf Man Mortal\nschema range hasChild Person\nschema domain hasChild Parent\nschema subPropertyOf hasChild hasDescendant\nschema disjointWith Alive Dead\nschema disjointProperties employs isEmployedBy\n</code></pre> <pre><code>pynmms tell -b onto_base.json --create --onto --batch onto_base.txt\n</code></pre> <p>Query batch:</p> <pre><code># queries.txt\nMan(socrates) =&gt; Mortal(socrates)\nhasChild(alice,bob) =&gt; Person(bob)\nhasChild(alice,bob) =&gt; Parent(alice)\nhasChild(alice,bob) =&gt; hasDescendant(alice,bob)\nMan(socrates) =&gt; Perishable(socrates)\n</code></pre> <pre><code>pynmms ask -b onto_base.json --onto --batch queries.txt\n</code></pre>"},{"location":"tutorial/onto-tutorial/#9-repl-commands","title":"9. REPL Commands","text":"<p>The ontology REPL (activated with <code>pynmms repl --onto</code>) provides all the standard REPL commands plus ontology-specific commands for managing schemas and inspecting vocabulary.</p>"},{"location":"tutorial/onto-tutorial/#schema-commands","title":"Schema Commands","text":"Command Description <code>tell schema subClassOf C D</code> Register subClassOf: {C(x)} |~ {D(x)} <code>tell schema range R C</code> Register range: {R(x,y)} |~ {C(y)} <code>tell schema domain R C</code> Register domain: {R(x,y)} |~ {C(x)} <code>tell schema subPropertyOf R S</code> Register subPropertyOf: {R(x,y)} |~ {S(x,y)} <code>tell schema disjointWith C D</code> Register disjointWith: {C(x), D(x)} |~ {} <code>tell schema disjointProperties R S</code> Register disjointProperties: {R(x,y), S(x,y)} |~ {}"},{"location":"tutorial/onto-tutorial/#inspection-commands","title":"Inspection Commands","text":"Command Description <code>show</code> Display atoms, annotations, and consequences <code>show schemas</code> Display all registered ontology schemas <code>show individuals</code> Display known individuals, concepts, and roles"},{"location":"tutorial/onto-tutorial/#complete-command-reference","title":"Complete Command Reference","text":"Command Description <code>tell A \\|~ B</code> Add a consequence to the base <code>tell A, B \\|~</code> Add incompatibility (empty consequent) <code>tell \\|~ A</code> Add theorem (empty antecedent) <code>tell atom C(a)</code> Add a concept assertion <code>tell atom R(a,b)</code> Add a role assertion <code>tell atom C(a) \"desc\"</code> Add an atom with annotation <code>tell schema subClassOf C D</code> Register subClassOf schema <code>tell schema range R C</code> Register range schema <code>tell schema domain R C</code> Register domain schema <code>tell schema subPropertyOf R S</code> Register subPropertyOf schema <code>tell schema disjointWith C D</code> Register disjointWith schema <code>tell schema disjointProperties R S</code> Register disjointProperties schema <code>ask A =&gt; B</code> Query derivability <code>show</code> Display the current base <code>show schemas</code> Display registered schemas <code>show individuals</code> Display vocabulary (individuals, concepts, roles) <code>trace on/off</code> Toggle proof trace display <code>save &lt;file&gt;</code> Save base to JSON <code>load &lt;file&gt;</code> Load base from JSON <code>help</code> Show available commands <code>quit</code> Exit the REPL"},{"location":"tutorial/onto-tutorial/#example-repl-session","title":"Example REPL Session","text":"<pre><code>$ pynmms repl --onto\nStarting with empty ontology base.\npyNMMS REPL (ontology mode). Type 'help' for commands.\n\npynmms[onto]&gt; tell atom Man(socrates) \"Socrates is a man\"\nAdded atom: Man(socrates) -- Socrates is a man\n\npynmms[onto]&gt; tell atom hasChild(alice,bob)\nAdded atom: hasChild(alice,bob)\n\npynmms[onto]&gt; tell schema subClassOf Man Mortal\nRegistered subClassOf schema: {Man(x)} |~ {Mortal(x)}\n\npynmms[onto]&gt; tell schema range hasChild Person\nRegistered range schema: {hasChild(x,y)} |~ {Person(y)}\n\npynmms[onto]&gt; tell schema domain hasChild Parent\nRegistered domain schema: {hasChild(x,y)} |~ {Parent(x)}\n\npynmms[onto]&gt; tell schema subPropertyOf hasChild hasDescendant\nRegistered subPropertyOf schema: {hasChild(x,y)} |~ {hasDescendant(x,y)}\n\npynmms[onto]&gt; tell schema disjointWith Alive Dead\nRegistered disjointWith schema: {Alive(x), Dead(x)} |~ {}\n\npynmms[onto]&gt; tell schema disjointProperties employs isEmployedBy\nRegistered disjointProperties schema: {employs(x,y), isEmployedBy(x,y)} |~ {}\n\npynmms[onto]&gt; show schemas\nSchemas (6):\n  subClassOf: {Man(x)} |~ {Mortal(x)}\n  range: {hasChild(x,y)} |~ {Person(y)}\n  domain: {hasChild(x,y)} |~ {Parent(x)}\n  subPropertyOf: {hasChild(x,y)} |~ {hasDescendant(x,y)}\n  disjointWith: {Alive(x), Dead(x)} |~ {}\n  disjointProperties: {employs(x,y), isEmployedBy(x,y)} |~ {}\n\npynmms[onto]&gt; show individuals\nIndividuals: ['alice', 'bob', 'socrates']\nConcepts: ['Man']\nRoles: ['hasChild']\n\npynmms[onto]&gt; ask Man(socrates) =&gt; Mortal(socrates)\nDERIVABLE\n\npynmms[onto]&gt; ask hasChild(alice,bob) =&gt; Person(bob)\nDERIVABLE\n\npynmms[onto]&gt; ask hasChild(alice,bob) =&gt; Parent(alice)\nDERIVABLE\n\npynmms[onto]&gt; ask hasChild(alice,bob) =&gt; hasDescendant(alice,bob)\nDERIVABLE\n\npynmms[onto]&gt; ask Man(socrates), Divine(socrates) =&gt; Mortal(socrates)\nNOT DERIVABLE\n\npynmms[onto]&gt; trace on\nTrace: ON\n\npynmms[onto]&gt; ask Man(socrates) =&gt; Mortal(socrates)\nDERIVABLE\n  AXIOM: Man(socrates) =&gt; Mortal(socrates)\n  Depth: 0, Cache hits: 0\n\npynmms[onto]&gt; save my_onto_base.json\nSaved to my_onto_base.json\n\npynmms[onto]&gt; quit\n</code></pre>"},{"location":"tutorial/onto-tutorial/#summary","title":"Summary","text":"<p>The ontology extension provides schema-level macros for material inferential commitments and incompatibilities within the NMMS framework:</p> Feature Mechanism ABox assertions Concept <code>C(a)</code> and role <code>R(a,b)</code> atoms in the material base TBox schemas <code>register_subclass</code>, <code>register_range</code>, <code>register_domain</code>, <code>register_subproperty</code>, <code>register_disjoint_concepts</code>, <code>register_disjoint_properties</code> Lazy evaluation Schemas checked at query time, not eagerly grounded Exact match No weakening -- preserves defeasibility Standard reasoner <code>NMMSReasoner</code> works transparently with <code>OntoMaterialBase</code> Defeasibility Extra premises defeat ontology inferences (no Weakening) Non-transitivity SubClassOf chains do not propagate (no Mixed-Cut) Incompatibility <code>disjointWith</code> and <code>disjointProperties</code> encode material incompatibility directly DDT Conditional form <code>A -&gt; B</code> derivable when material inference holds CommitmentStore Higher-level API with source tracking and retraction CLI <code>--onto</code> flag on <code>tell</code>, <code>ask</code>, <code>repl</code>"},{"location":"tutorial/proof-search/","title":"Proof Search","text":""},{"location":"tutorial/proof-search/#using-the-reasoner","title":"Using the Reasoner","text":"<pre><code>from pynmms import MaterialBase, NMMSReasoner\n\nbase = MaterialBase(\n    language={\"A\", \"B\"},\n    consequences={(frozenset({\"A\"}), frozenset({\"B\"}))},\n)\nreasoner = NMMSReasoner(base, max_depth=25)\n</code></pre>"},{"location":"tutorial/proof-search/#derives-full-result","title":"<code>derives()</code> \u2014 Full Result","text":"<pre><code>result = reasoner.derives(frozenset({\"A\"}), frozenset({\"B\"}))\nprint(result.derivable)      # True\nprint(result.trace)          # ['AXIOM: A =&gt; B']\nprint(result.depth_reached)  # 0\nprint(result.cache_hits)     # 0\n</code></pre>"},{"location":"tutorial/proof-search/#query-boolean-only","title":"<code>query()</code> \u2014 Boolean Only","text":"<pre><code>reasoner.query(frozenset({\"A\"}), frozenset({\"B\"}))  # True\n</code></pre>"},{"location":"tutorial/proof-search/#reading-proof-traces","title":"Reading Proof Traces","text":"<p>The trace records every rule application and axiom closure:</p> <pre><code>result = reasoner.derives(frozenset(), frozenset({\"A -&gt; B\"}))\nfor line in result.trace:\n    print(line)\n</code></pre> <p>Output: <pre><code>[R\u2192] on A -&gt; B\n  AXIOM: A =&gt; B\n</code></pre></p> <p>Trace entries include: - <code>AXIOM: Gamma =&gt; Delta</code> \u2014 leaf of the proof tree (base axiom or containment) - <code>[L\u00ac] on ~A</code> \u2014 left negation rule applied - <code>[L\u2192] on A -&gt; B</code> \u2014 left implication rule (3 premises) - <code>[L\u2227] on A &amp; B</code> \u2014 left conjunction rule - <code>[L\u2228] on A | B</code> \u2014 left disjunction rule (3 premises, Ketonen pattern) - <code>[R\u00ac] on ~A</code> \u2014 right negation rule - <code>[R\u2192] on A -&gt; B</code> \u2014 right implication rule - <code>[R\u2227] on A &amp; B</code> \u2014 right conjunction rule (3 premises, Ketonen pattern) - <code>[R\u2228] on A | B</code> \u2014 right disjunction rule - <code>FAIL: Gamma =&gt; Delta</code> \u2014 no rule could close this branch - <code>DEPTH LIMIT</code> \u2014 maximum proof depth exceeded</p>"},{"location":"tutorial/proof-search/#depth-limit","title":"Depth Limit","text":"<p>The <code>max_depth</code> parameter (default 25) prevents infinite proof search:</p> <pre><code>reasoner = NMMSReasoner(base, max_depth=10)\n</code></pre> <p>If the depth limit is reached, the proof search returns <code>False</code> for that branch.</p>"},{"location":"tutorial/proof-search/#memoization","title":"Memoization","text":"<p>The reasoner uses memoization to avoid re-proving identical subgoals. The <code>cache_hits</code> field in <code>ProofResult</code> reports how many times a cached result was reused.</p>"}]}