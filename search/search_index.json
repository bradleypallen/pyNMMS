{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"pyNMMS","text":"<p>An automated reasoner for the Non-Monotonic Multi-Succedent (NMMS) propositional sequent calculus from Hlobil &amp; Brandom 2025, Ch. 3.</p> <p>pyNMMS implements a proof search engine for the NMMS sequent calculus, which codifies open reason relations \u2014 consequence relations where Monotonicity and Transitivity can fail.</p>"},{"location":"#why-pynmms","title":"Why pyNMMS?","text":"<p>Traditional logics assume that adding premises never defeats an inference (Monotonicity) and that chaining good inferences always yields good inferences (Transitivity). But real-world reasoning is often defeasible: new information can override previous conclusions.</p> <p>pyNMMS provides:</p> <ul> <li>A material base for encoding defeasible inferences among atomic sentences</li> <li>Backward proof search implementing all 8 propositional NMMS rules</li> <li>Supraclassicality: all classically valid sequents remain derivable</li> <li>A Tell/Ask CLI and interactive REPL for exploring reason relations</li> <li>Full proof traces for understanding derivations</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from pynmms import MaterialBase, NMMSReasoner\n\nbase = MaterialBase(\n    language={\"A\", \"B\", \"C\"},\n    consequences={\n        (frozenset({\"A\"}), frozenset({\"B\"})),  # A |~ B\n        (frozenset({\"B\"}), frozenset({\"C\"})),  # B |~ C\n    },\n)\nreasoner = NMMSReasoner(base)\n\nreasoner.query(frozenset({\"A\"}), frozenset({\"B\"}))  # True (base consequence)\nreasoner.query(frozenset({\"A\"}), frozenset({\"C\"}))  # False (nontransitive!)\nreasoner.query(frozenset({\"A\", \"C\"}), frozenset({\"B\"}))  # False (nonmonotonic!)\nreasoner.query(frozenset(), frozenset({\"A | ~A\"}))  # True (supraclassical)\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pyNMMS\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<pre><code>pip install pyNMMS\n</code></pre> <p>For development:</p> <pre><code>git clone https://github.com/bradleyallen/nmms-reasoner.git\ncd nmms-reasoner\npip install -e \".[dev]\"\n</code></pre>"},{"location":"getting-started/#your-first-material-base","title":"Your First Material Base","text":"<p>A material base encodes defeasible material inferences among atomic sentences.</p> <pre><code>from pynmms import MaterialBase, NMMSReasoner\n\n# Create a base: \"rain\" defeasibly implies \"wet ground\"\nbase = MaterialBase(\n    language={\"rain\", \"wet_ground\", \"covered\"},\n    consequences={\n        (frozenset({\"rain\"}), frozenset({\"wet_ground\"})),\n    },\n)\n</code></pre>"},{"location":"getting-started/#querying-derivability","title":"Querying Derivability","text":"<pre><code>reasoner = NMMSReasoner(base)\n\n# Does rain derive wet ground?\nresult = reasoner.derives(frozenset({\"rain\"}), frozenset({\"wet_ground\"}))\nprint(result.derivable)  # True\n\n# Nonmonotonicity: adding \"covered\" defeats the inference\nresult = reasoner.derives(\n    frozenset({\"rain\", \"covered\"}),\n    frozenset({\"wet_ground\"})\n)\nprint(result.derivable)  # False \u2014 no weakening!\n</code></pre>"},{"location":"getting-started/#using-the-cli","title":"Using the CLI","text":"<pre><code># Create a base\npynmms tell -b mybase.json --create \"rain |~ wet_ground\"\n\n# Query it\npynmms ask -b mybase.json \"rain =&gt; wet_ground\"        # DERIVABLE\npynmms ask -b mybase.json \"rain, covered =&gt; wet_ground\"  # NOT DERIVABLE\n\n# Interactive REPL\npynmms repl -b mybase.json\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Key Concepts \u2014 understand material bases, nonmonotonicity, and sequents</li> <li>Proof Search \u2014 how the reasoner works and how to read traces</li> <li>CLI Usage \u2014 full guide to the Tell/Ask CLI and REPL</li> </ul>"},{"location":"api/base/","title":"MaterialBase","text":""},{"location":"api/base/#pynmms.base.MaterialBase","title":"<code>pynmms.base.MaterialBase</code>  <code>dataclass</code>","text":"<p>A material base B =  for propositional NMMS. <p>Parameters:</p> Name Type Description Default <code>language</code> <code>set[str] | frozenset[str] | None</code> <p>Set of atomic sentence strings comprising L_B.</p> <code>None</code> <code>consequences</code> <code>set[Sequent] | set[tuple[frozenset[str], frozenset[str]]] | None</code> <p>Set of (antecedent, consequent) sequent pairs comprising |~_B.</p> <code>None</code> Source code in <code>pynmms/base.py</code> <pre><code>@dataclass\nclass MaterialBase:\n    \"\"\"A material base B = &lt;L_B, |~_B&gt; for propositional NMMS.\n\n    Parameters:\n        language: Set of atomic sentence strings comprising L_B.\n        consequences: Set of (antecedent, consequent) sequent pairs comprising |~_B.\n    \"\"\"\n\n    _language: set[str] = field(default_factory=set)\n    _consequences: set[Sequent] = field(default_factory=set)\n\n    def __init__(\n        self,\n        language: set[str] | frozenset[str] | None = None,\n        consequences: (\n            set[Sequent]\n            | set[tuple[frozenset[str], frozenset[str]]]\n            | None\n        ) = None,\n    ) -&gt; None:\n        self._language: set[str] = set(language) if language else set()\n        self._consequences: set[Sequent] = set()\n\n        # Validate all language atoms\n        for s in self._language:\n            _validate_atomic(s, \"Material base language\")\n\n        # Validate and store consequences\n        if consequences:\n            for gamma, delta in consequences:\n                for s in gamma | delta:\n                    _validate_atomic(s, \"Material base consequence\")\n                self._consequences.add((gamma, delta))\n\n        logger.debug(\n            \"MaterialBase created: %d atoms, %d consequences\",\n            len(self._language),\n            len(self._consequences),\n        )\n\n    # --- Read-only properties ---\n\n    @property\n    def language(self) -&gt; frozenset[str]:\n        \"\"\"The atomic language L_B (read-only view).\"\"\"\n        return frozenset(self._language)\n\n    @property\n    def consequences(self) -&gt; frozenset[Sequent]:\n        \"\"\"The base consequence relation |~_B (read-only view).\"\"\"\n        return frozenset(self._consequences)\n\n    # --- Mutation ---\n\n    def add_atom(self, s: str) -&gt; None:\n        \"\"\"Add an atomic sentence to the language L_B.\"\"\"\n        _validate_atomic(s, \"add_atom\")\n        self._language.add(s)\n        logger.debug(\"Added atom: %s\", s)\n\n    def add_consequence(self, antecedent: frozenset[str], consequent: frozenset[str]) -&gt; None:\n        \"\"\"Add a base consequence Gamma |~_B Delta.\n\n        All sentences in *antecedent* and *consequent* must be atomic. They are\n        also implicitly added to the language.\n        \"\"\"\n        for s in antecedent | consequent:\n            _validate_atomic(s, \"add_consequence\")\n            self._language.add(s)\n        self._consequences.add((antecedent, consequent))\n        logger.debug(\"Added consequence: %s |~ %s\", set(antecedent), set(consequent))\n\n    # --- Axiom check ---\n\n    def is_axiom(self, gamma: frozenset[str], delta: frozenset[str]) -&gt; bool:\n        \"\"\"Check if Gamma =&gt; Delta is an axiom of NMMS_B.\n\n        Ax1 (Containment): Gamma \u2229 Delta \u2260 \u2205.\n        Ax2 (Base consequence): (Gamma, Delta) \u2208 |~_B exactly.\n\n        No Weakening: the base relation uses exact syntactic match.\n        \"\"\"\n        # Ax1: Containment\n        if gamma &amp; delta:\n            return True\n        # Ax2: Explicit base consequence (exact match)\n        if (gamma, delta) in self._consequences:\n            return True\n        return False\n\n    # --- Serialization ---\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Serialize to a JSON-compatible dict.\"\"\"\n        return {\n            \"language\": sorted(self._language),\n            \"consequences\": [\n                {\n                    \"antecedent\": sorted(gamma),\n                    \"consequent\": sorted(delta),\n                }\n                for gamma, delta in sorted(\n                    self._consequences, key=lambda s: (sorted(s[0]), sorted(s[1]))\n                )\n            ],\n        }\n\n    @classmethod\n    def from_dict(cls, data: dict) -&gt; MaterialBase:\n        \"\"\"Deserialize from a dict (as produced by ``to_dict``).\"\"\"\n        language = set(data.get(\"language\", []))\n        consequences: set[Sequent] = set()\n        for entry in data.get(\"consequences\", []):\n            gamma = frozenset(entry[\"antecedent\"])\n            delta = frozenset(entry[\"consequent\"])\n            consequences.add((gamma, delta))\n        return cls(language=language, consequences=consequences)\n\n    def to_file(self, path: str | Path) -&gt; None:\n        \"\"\"Write the base to a JSON file.\"\"\"\n        with open(path, \"w\") as f:\n            json.dump(self.to_dict(), f, indent=2)\n        logger.debug(\"Saved base to %s\", path)\n\n    @classmethod\n    def from_file(cls, path: str | Path) -&gt; MaterialBase:\n        \"\"\"Load a base from a JSON file.\"\"\"\n        with open(path) as f:\n            data = json.load(f)\n        logger.debug(\"Loaded base from %s\", path)\n        return cls.from_dict(data)\n</code></pre>"},{"location":"api/base/#pynmms.base.MaterialBase.language","title":"<code>language</code>  <code>property</code>","text":"<p>The atomic language L_B (read-only view).</p>"},{"location":"api/base/#pynmms.base.MaterialBase.consequences","title":"<code>consequences</code>  <code>property</code>","text":"<p>The base consequence relation |~_B (read-only view).</p>"},{"location":"api/base/#pynmms.base.MaterialBase.__init__","title":"<code>__init__(language=None, consequences=None)</code>","text":"Source code in <code>pynmms/base.py</code> <pre><code>def __init__(\n    self,\n    language: set[str] | frozenset[str] | None = None,\n    consequences: (\n        set[Sequent]\n        | set[tuple[frozenset[str], frozenset[str]]]\n        | None\n    ) = None,\n) -&gt; None:\n    self._language: set[str] = set(language) if language else set()\n    self._consequences: set[Sequent] = set()\n\n    # Validate all language atoms\n    for s in self._language:\n        _validate_atomic(s, \"Material base language\")\n\n    # Validate and store consequences\n    if consequences:\n        for gamma, delta in consequences:\n            for s in gamma | delta:\n                _validate_atomic(s, \"Material base consequence\")\n            self._consequences.add((gamma, delta))\n\n    logger.debug(\n        \"MaterialBase created: %d atoms, %d consequences\",\n        len(self._language),\n        len(self._consequences),\n    )\n</code></pre>"},{"location":"api/base/#pynmms.base.MaterialBase.add_atom","title":"<code>add_atom(s)</code>","text":"<p>Add an atomic sentence to the language L_B.</p> Source code in <code>pynmms/base.py</code> <pre><code>def add_atom(self, s: str) -&gt; None:\n    \"\"\"Add an atomic sentence to the language L_B.\"\"\"\n    _validate_atomic(s, \"add_atom\")\n    self._language.add(s)\n    logger.debug(\"Added atom: %s\", s)\n</code></pre>"},{"location":"api/base/#pynmms.base.MaterialBase.add_consequence","title":"<code>add_consequence(antecedent, consequent)</code>","text":"<p>Add a base consequence Gamma |~_B Delta.</p> <p>All sentences in antecedent and consequent must be atomic. They are also implicitly added to the language.</p> Source code in <code>pynmms/base.py</code> <pre><code>def add_consequence(self, antecedent: frozenset[str], consequent: frozenset[str]) -&gt; None:\n    \"\"\"Add a base consequence Gamma |~_B Delta.\n\n    All sentences in *antecedent* and *consequent* must be atomic. They are\n    also implicitly added to the language.\n    \"\"\"\n    for s in antecedent | consequent:\n        _validate_atomic(s, \"add_consequence\")\n        self._language.add(s)\n    self._consequences.add((antecedent, consequent))\n    logger.debug(\"Added consequence: %s |~ %s\", set(antecedent), set(consequent))\n</code></pre>"},{"location":"api/base/#pynmms.base.MaterialBase.is_axiom","title":"<code>is_axiom(gamma, delta)</code>","text":"<p>Check if Gamma =&gt; Delta is an axiom of NMMS_B.</p> <p>Ax1 (Containment): Gamma \u2229 Delta \u2260 \u2205. Ax2 (Base consequence): (Gamma, Delta) \u2208 |~_B exactly.</p> <p>No Weakening: the base relation uses exact syntactic match.</p> Source code in <code>pynmms/base.py</code> <pre><code>def is_axiom(self, gamma: frozenset[str], delta: frozenset[str]) -&gt; bool:\n    \"\"\"Check if Gamma =&gt; Delta is an axiom of NMMS_B.\n\n    Ax1 (Containment): Gamma \u2229 Delta \u2260 \u2205.\n    Ax2 (Base consequence): (Gamma, Delta) \u2208 |~_B exactly.\n\n    No Weakening: the base relation uses exact syntactic match.\n    \"\"\"\n    # Ax1: Containment\n    if gamma &amp; delta:\n        return True\n    # Ax2: Explicit base consequence (exact match)\n    if (gamma, delta) in self._consequences:\n        return True\n    return False\n</code></pre>"},{"location":"api/base/#pynmms.base.MaterialBase.to_dict","title":"<code>to_dict()</code>","text":"<p>Serialize to a JSON-compatible dict.</p> Source code in <code>pynmms/base.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Serialize to a JSON-compatible dict.\"\"\"\n    return {\n        \"language\": sorted(self._language),\n        \"consequences\": [\n            {\n                \"antecedent\": sorted(gamma),\n                \"consequent\": sorted(delta),\n            }\n            for gamma, delta in sorted(\n                self._consequences, key=lambda s: (sorted(s[0]), sorted(s[1]))\n            )\n        ],\n    }\n</code></pre>"},{"location":"api/base/#pynmms.base.MaterialBase.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Deserialize from a dict (as produced by <code>to_dict</code>).</p> Source code in <code>pynmms/base.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict) -&gt; MaterialBase:\n    \"\"\"Deserialize from a dict (as produced by ``to_dict``).\"\"\"\n    language = set(data.get(\"language\", []))\n    consequences: set[Sequent] = set()\n    for entry in data.get(\"consequences\", []):\n        gamma = frozenset(entry[\"antecedent\"])\n        delta = frozenset(entry[\"consequent\"])\n        consequences.add((gamma, delta))\n    return cls(language=language, consequences=consequences)\n</code></pre>"},{"location":"api/base/#pynmms.base.MaterialBase.to_file","title":"<code>to_file(path)</code>","text":"<p>Write the base to a JSON file.</p> Source code in <code>pynmms/base.py</code> <pre><code>def to_file(self, path: str | Path) -&gt; None:\n    \"\"\"Write the base to a JSON file.\"\"\"\n    with open(path, \"w\") as f:\n        json.dump(self.to_dict(), f, indent=2)\n    logger.debug(\"Saved base to %s\", path)\n</code></pre>"},{"location":"api/base/#pynmms.base.MaterialBase.from_file","title":"<code>from_file(path)</code>  <code>classmethod</code>","text":"<p>Load a base from a JSON file.</p> Source code in <code>pynmms/base.py</code> <pre><code>@classmethod\ndef from_file(cls, path: str | Path) -&gt; MaterialBase:\n    \"\"\"Load a base from a JSON file.\"\"\"\n    with open(path) as f:\n        data = json.load(f)\n    logger.debug(\"Loaded base from %s\", path)\n    return cls.from_dict(data)\n</code></pre>"},{"location":"api/reasoner/","title":"NMMSReasoner","text":""},{"location":"api/reasoner/#pynmms.reasoner.NMMSReasoner","title":"<code>pynmms.reasoner.NMMSReasoner</code>","text":"<p>Proof search for propositional NMMS sequent calculus.</p> <p>Performs backward (root-first) proof search with memoization and depth-limited search. A sequent Gamma =&gt; Delta is derivable iff all leaves of its proof tree are axioms of the material base.</p> <p>Parameters:</p> Name Type Description Default <code>base</code> <code>MaterialBase</code> <p>The material base providing axioms.</p> required <code>max_depth</code> <code>int</code> <p>Maximum proof depth (default 25).</p> <code>25</code> Source code in <code>pynmms/reasoner.py</code> <pre><code>class NMMSReasoner:\n    \"\"\"Proof search for propositional NMMS sequent calculus.\n\n    Performs backward (root-first) proof search with memoization and\n    depth-limited search. A sequent Gamma =&gt; Delta is derivable iff\n    all leaves of its proof tree are axioms of the material base.\n\n    Parameters:\n        base: The material base providing axioms.\n        max_depth: Maximum proof depth (default 25).\n    \"\"\"\n\n    def __init__(self, base: MaterialBase, *, max_depth: int = 25) -&gt; None:\n        self.base = base\n        self.max_depth = max_depth\n        self._trace: list[str] = []\n        self._cache: dict[tuple[frozenset[str], frozenset[str]], bool] = {}\n        self._depth_reached: int = 0\n        self._cache_hits: int = 0\n\n    def derives(self, antecedent: frozenset[str], consequent: frozenset[str]) -&gt; ProofResult:\n        \"\"\"Check if ``antecedent =&gt; consequent`` is derivable in NMMS_B.\n\n        Returns a ``ProofResult`` with derivability, proof trace, and statistics.\n        \"\"\"\n        self._trace = []\n        self._cache = {}\n        self._depth_reached = 0\n        self._cache_hits = 0\n\n        logger.debug(\"Proof search: %s =&gt; %s\", _fmt(antecedent), _fmt(consequent))\n        result = self._prove(antecedent, consequent, depth=0)\n        logger.debug(\"Result: %s (depth %d, cache hits %d)\",\n                      result, self._depth_reached, self._cache_hits)\n\n        return ProofResult(\n            derivable=result,\n            trace=list(self._trace),\n            depth_reached=self._depth_reached,\n            cache_hits=self._cache_hits,\n        )\n\n    def query(self, antecedent: frozenset[str], consequent: frozenset[str]) -&gt; bool:\n        \"\"\"Convenience method: return only the derivability boolean.\"\"\"\n        return self.derives(antecedent, consequent).derivable\n\n    # ------------------------------------------------------------------\n    # Internal proof search\n    # ------------------------------------------------------------------\n\n    def _prove(self, gamma: frozenset[str], delta: frozenset[str], depth: int) -&gt; bool:\n        \"\"\"Backward proof search with memoization.\"\"\"\n        indent = \"  \" * depth\n        self._depth_reached = max(self._depth_reached, depth)\n\n        if depth &gt; self.max_depth:\n            msg = f\"{indent}DEPTH LIMIT\"\n            self._trace.append(msg)\n            logger.debug(msg)\n            return False\n\n        # Memoization\n        key = (gamma, delta)\n        if key in self._cache:\n            self._cache_hits += 1\n            return self._cache[key]\n\n        # Check axiom\n        if self.base.is_axiom(gamma, delta):\n            msg = f\"{indent}AXIOM: {_fmt(gamma)} =&gt; {_fmt(delta)}\"\n            self._trace.append(msg)\n            logger.debug(msg)\n            self._cache[key] = True\n            return True\n\n        # Mark as False initially to detect cycles\n        self._cache[key] = False\n\n        result = self._try_left_rules(gamma, delta, depth) or self._try_right_rules(\n            gamma, delta, depth\n        )\n\n        self._cache[key] = result\n        if not result:\n            msg = f\"{indent}FAIL: {_fmt(gamma)} =&gt; {_fmt(delta)}\"\n            self._trace.append(msg)\n            logger.debug(msg)\n        return result\n\n    # ------------------------------------------------------------------\n    # LEFT RULES\n    # ------------------------------------------------------------------\n\n    def _try_left_rules(\n        self, gamma: frozenset[str], delta: frozenset[str], depth: int\n    ) -&gt; bool:\n        indent = \"  \" * depth\n\n        for s in sorted(gamma):  # sorted for determinism\n            parsed = parse_sentence(s)\n            rest = gamma - {s}\n\n            # [L~]: Gamma, ~A =&gt; Delta  &lt;-  Gamma =&gt; Delta, A\n            if parsed.type == NEG:\n                assert parsed.sub is not None\n                a = str(parsed.sub)\n                msg = f\"{indent}[L\\u00ac] on {s}\"\n                self._trace.append(msg)\n                logger.debug(msg)\n                if self._prove(rest, delta | {a}, depth + 1):\n                    return True\n\n            # [L-&gt;]: Gamma, A-&gt;B =&gt; Delta  &lt;-  (1) Gamma =&gt; Delta, A\n            #                                   (2) Gamma, B =&gt; Delta\n            #                                   (3) Gamma, B =&gt; Delta, A\n            elif parsed.type == IMPL:\n                assert parsed.left is not None and parsed.right is not None\n                a, b = str(parsed.left), str(parsed.right)\n                msg = f\"{indent}[L\\u2192] on {s}\"\n                self._trace.append(msg)\n                logger.debug(msg)\n                if (\n                    self._prove(rest, delta | {a}, depth + 1)\n                    and self._prove(rest | {b}, delta, depth + 1)\n                    and self._prove(rest | {b}, delta | {a}, depth + 1)\n                ):\n                    return True\n\n            # [L&amp;]: Gamma, A &amp; B =&gt; Delta  &lt;-  Gamma, A, B =&gt; Delta\n            elif parsed.type == CONJ:\n                assert parsed.left is not None and parsed.right is not None\n                a, b = str(parsed.left), str(parsed.right)\n                msg = f\"{indent}[L\\u2227] on {s}\"\n                self._trace.append(msg)\n                logger.debug(msg)\n                if self._prove(rest | {a, b}, delta, depth + 1):\n                    return True\n\n            # [L|]: Gamma, A | B =&gt; Delta  &lt;-  (1) Gamma, A =&gt; Delta\n            #                                   (2) Gamma, B =&gt; Delta\n            #                                   (3) Gamma, A, B =&gt; Delta\n            elif parsed.type == DISJ:\n                assert parsed.left is not None and parsed.right is not None\n                a, b = str(parsed.left), str(parsed.right)\n                msg = f\"{indent}[L\\u2228] on {s}\"\n                self._trace.append(msg)\n                logger.debug(msg)\n                if (\n                    self._prove(rest | {a}, delta, depth + 1)\n                    and self._prove(rest | {b}, delta, depth + 1)\n                    and self._prove(rest | {a, b}, delta, depth + 1)\n                ):\n                    return True\n\n        return False\n\n    # ------------------------------------------------------------------\n    # RIGHT RULES\n    # ------------------------------------------------------------------\n\n    def _try_right_rules(\n        self, gamma: frozenset[str], delta: frozenset[str], depth: int\n    ) -&gt; bool:\n        indent = \"  \" * depth\n\n        for s in sorted(delta):\n            parsed = parse_sentence(s)\n            rest = delta - {s}\n\n            # [R~]: Gamma =&gt; Delta, ~A  &lt;-  Gamma, A =&gt; Delta\n            if parsed.type == NEG:\n                assert parsed.sub is not None\n                a = str(parsed.sub)\n                msg = f\"{indent}[R\\u00ac] on {s}\"\n                self._trace.append(msg)\n                logger.debug(msg)\n                if self._prove(gamma | {a}, rest, depth + 1):\n                    return True\n\n            # [R-&gt;]: Gamma =&gt; Delta, A-&gt;B  &lt;-  Gamma, A =&gt; Delta, B\n            elif parsed.type == IMPL:\n                assert parsed.left is not None and parsed.right is not None\n                a, b = str(parsed.left), str(parsed.right)\n                msg = f\"{indent}[R\\u2192] on {s}\"\n                self._trace.append(msg)\n                logger.debug(msg)\n                if self._prove(gamma | {a}, rest | {b}, depth + 1):\n                    return True\n\n            # [R&amp;]: Gamma =&gt; Delta, A &amp; B  &lt;-  (1) Gamma =&gt; Delta, A\n            #                                   (2) Gamma =&gt; Delta, B\n            #                                   (3) Gamma =&gt; Delta, A, B\n            elif parsed.type == CONJ:\n                assert parsed.left is not None and parsed.right is not None\n                a, b = str(parsed.left), str(parsed.right)\n                msg = f\"{indent}[R\\u2227] on {s}\"\n                self._trace.append(msg)\n                logger.debug(msg)\n                if (\n                    self._prove(gamma, rest | {a}, depth + 1)\n                    and self._prove(gamma, rest | {b}, depth + 1)\n                    and self._prove(gamma, rest | {a, b}, depth + 1)\n                ):\n                    return True\n\n            # [R|]: Gamma =&gt; Delta, A | B  &lt;-  Gamma =&gt; Delta, A, B\n            elif parsed.type == DISJ:\n                assert parsed.left is not None and parsed.right is not None\n                a, b = str(parsed.left), str(parsed.right)\n                msg = f\"{indent}[R\\u2228] on {s}\"\n                self._trace.append(msg)\n                logger.debug(msg)\n                if self._prove(gamma, rest | {a, b}, depth + 1):\n                    return True\n\n        return False\n</code></pre>"},{"location":"api/reasoner/#pynmms.reasoner.NMMSReasoner.__init__","title":"<code>__init__(base, *, max_depth=25)</code>","text":"Source code in <code>pynmms/reasoner.py</code> <pre><code>def __init__(self, base: MaterialBase, *, max_depth: int = 25) -&gt; None:\n    self.base = base\n    self.max_depth = max_depth\n    self._trace: list[str] = []\n    self._cache: dict[tuple[frozenset[str], frozenset[str]], bool] = {}\n    self._depth_reached: int = 0\n    self._cache_hits: int = 0\n</code></pre>"},{"location":"api/reasoner/#pynmms.reasoner.NMMSReasoner.derives","title":"<code>derives(antecedent, consequent)</code>","text":"<p>Check if <code>antecedent =&gt; consequent</code> is derivable in NMMS_B.</p> <p>Returns a <code>ProofResult</code> with derivability, proof trace, and statistics.</p> Source code in <code>pynmms/reasoner.py</code> <pre><code>def derives(self, antecedent: frozenset[str], consequent: frozenset[str]) -&gt; ProofResult:\n    \"\"\"Check if ``antecedent =&gt; consequent`` is derivable in NMMS_B.\n\n    Returns a ``ProofResult`` with derivability, proof trace, and statistics.\n    \"\"\"\n    self._trace = []\n    self._cache = {}\n    self._depth_reached = 0\n    self._cache_hits = 0\n\n    logger.debug(\"Proof search: %s =&gt; %s\", _fmt(antecedent), _fmt(consequent))\n    result = self._prove(antecedent, consequent, depth=0)\n    logger.debug(\"Result: %s (depth %d, cache hits %d)\",\n                  result, self._depth_reached, self._cache_hits)\n\n    return ProofResult(\n        derivable=result,\n        trace=list(self._trace),\n        depth_reached=self._depth_reached,\n        cache_hits=self._cache_hits,\n    )\n</code></pre>"},{"location":"api/reasoner/#pynmms.reasoner.NMMSReasoner.query","title":"<code>query(antecedent, consequent)</code>","text":"<p>Convenience method: return only the derivability boolean.</p> Source code in <code>pynmms/reasoner.py</code> <pre><code>def query(self, antecedent: frozenset[str], consequent: frozenset[str]) -&gt; bool:\n    \"\"\"Convenience method: return only the derivability boolean.\"\"\"\n    return self.derives(antecedent, consequent).derivable\n</code></pre>"},{"location":"api/reasoner/#pynmms.reasoner.ProofResult","title":"<code>pynmms.reasoner.ProofResult</code>  <code>dataclass</code>","text":"<p>Result of a proof search.</p> <p>Attributes:</p> Name Type Description <code>derivable</code> <code>bool</code> <p>Whether the sequent is derivable.</p> <code>trace</code> <code>list[str]</code> <p>Human-readable proof trace.</p> <code>depth_reached</code> <code>int</code> <p>Maximum proof depth reached.</p> <code>cache_hits</code> <code>int</code> <p>Number of memoization cache hits.</p> Source code in <code>pynmms/reasoner.py</code> <pre><code>@dataclass\nclass ProofResult:\n    \"\"\"Result of a proof search.\n\n    Attributes:\n        derivable: Whether the sequent is derivable.\n        trace: Human-readable proof trace.\n        depth_reached: Maximum proof depth reached.\n        cache_hits: Number of memoization cache hits.\n    \"\"\"\n\n    derivable: bool\n    trace: list[str] = field(default_factory=list)\n    depth_reached: int = 0\n    cache_hits: int = 0\n</code></pre>"},{"location":"api/syntax/","title":"Syntax","text":""},{"location":"api/syntax/#pynmms.syntax.Sentence","title":"<code>pynmms.syntax.Sentence</code>  <code>dataclass</code>","text":"<p>Immutable AST node for a propositional sentence.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>str</code> <p>One of ATOM, NEG, CONJ, DISJ, IMPL.</p> <code>name</code> <code>str | None</code> <p>The atom name (only when type == ATOM).</p> <code>sub</code> <code>Sentence | None</code> <p>The sub-sentence (only when type == NEG).</p> <code>left</code> <code>Sentence | None</code> <p>Left operand (only when type in {CONJ, DISJ, IMPL}).</p> <code>right</code> <code>Sentence | None</code> <p>Right operand (only when type in {CONJ, DISJ, IMPL}).</p> Source code in <code>pynmms/syntax.py</code> <pre><code>@dataclass(frozen=True, slots=True)\nclass Sentence:\n    \"\"\"Immutable AST node for a propositional sentence.\n\n    Attributes:\n        type: One of ATOM, NEG, CONJ, DISJ, IMPL.\n        name: The atom name (only when type == ATOM).\n        sub: The sub-sentence (only when type == NEG).\n        left: Left operand (only when type in {CONJ, DISJ, IMPL}).\n        right: Right operand (only when type in {CONJ, DISJ, IMPL}).\n    \"\"\"\n\n    type: str\n    name: str | None = None\n    sub: Sentence | None = None\n    left: Sentence | None = None\n    right: Sentence | None = None\n\n    def __str__(self) -&gt; str:\n        if self.type == ATOM:\n            return self.name  # type: ignore[return-value]\n        if self.type == NEG:\n            return f\"~{self.sub}\"\n        if self.type == CONJ:\n            return f\"({self.left} &amp; {self.right})\"\n        if self.type == DISJ:\n            return f\"({self.left} | {self.right})\"\n        if self.type == IMPL:\n            return f\"({self.left} -&gt; {self.right})\"\n        return f\"Sentence({self.type})\"  # pragma: no cover\n</code></pre>"},{"location":"api/syntax/#pynmms.syntax.parse_sentence","title":"<code>pynmms.syntax.parse_sentence(s)</code>","text":"<p>Parse a string into a propositional Sentence AST.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; parse_sentence(\"A\")\nSentence(type='atom', name='A', ...)\n&gt;&gt;&gt; parse_sentence(\"A -&gt; B\")\nSentence(type='impl', ..., left=Sentence(type='atom', name='A', ...),\n         right=Sentence(type='atom', name='B', ...))\n</code></pre> Source code in <code>pynmms/syntax.py</code> <pre><code>def parse_sentence(s: str) -&gt; Sentence:\n    \"\"\"Parse a string into a propositional Sentence AST.\n\n    Examples:\n        &gt;&gt;&gt; parse_sentence(\"A\")\n        Sentence(type='atom', name='A', ...)\n        &gt;&gt;&gt; parse_sentence(\"A -&gt; B\")\n        Sentence(type='impl', ..., left=Sentence(type='atom', name='A', ...),\n                 right=Sentence(type='atom', name='B', ...))\n    \"\"\"\n    s = s.strip()\n    if not s:\n        raise ValueError(\"Cannot parse empty sentence\")\n\n    # Strip outer parens if they wrap the entire expression\n    if s.startswith(\"(\") and s.endswith(\")\"):\n        depth = 0\n        all_wrapped = True\n        for i, c in enumerate(s):\n            if c == \"(\":\n                depth += 1\n            elif c == \")\":\n                depth -= 1\n            if depth == 0 and i &lt; len(s) - 1:\n                all_wrapped = False\n                break\n        if all_wrapped:\n            return parse_sentence(s[1:-1])\n\n    # --- Binary connectives at depth 0, lowest precedence first ---\n\n    # Implication (right-associative, lowest precedence)\n    # Scan left-to-right: first match gives right-associativity\n    depth = 0\n    for i in range(len(s)):\n        c = s[i]\n        if c == \"(\":\n            depth += 1\n        elif c == \")\":\n            depth -= 1\n        elif depth == 0 and s[i : i + 2] == \"-&gt;\":\n            left_str = s[:i].strip()\n            right_str = s[i + 2 :].strip()\n            if not left_str or not right_str:\n                raise ValueError(f\"Malformed implication in: {s!r}\")\n            return Sentence(\n                type=IMPL,\n                left=parse_sentence(left_str),\n                right=parse_sentence(right_str),\n            )\n\n    # Disjunction (left-associative) \u2014 find last '|' at depth 0\n    depth = 0\n    last_disj = -1\n    for i, c in enumerate(s):\n        if c == \"(\":\n            depth += 1\n        elif c == \")\":\n            depth -= 1\n        elif depth == 0 and c == \"|\":\n            last_disj = i\n    if last_disj &gt;= 0:\n        left_str = s[:last_disj].strip()\n        right_str = s[last_disj + 1 :].strip()\n        if not left_str or not right_str:\n            raise ValueError(f\"Malformed disjunction in: {s!r}\")\n        return Sentence(\n            type=DISJ,\n            left=parse_sentence(left_str),\n            right=parse_sentence(right_str),\n        )\n\n    # Conjunction (left-associative) \u2014 find last '&amp;' at depth 0\n    depth = 0\n    last_conj = -1\n    for i, c in enumerate(s):\n        if c == \"(\":\n            depth += 1\n        elif c == \")\":\n            depth -= 1\n        elif depth == 0 and c == \"&amp;\":\n            last_conj = i\n    if last_conj &gt;= 0:\n        left_str = s[:last_conj].strip()\n        right_str = s[last_conj + 1 :].strip()\n        if not left_str or not right_str:\n            raise ValueError(f\"Malformed conjunction in: {s!r}\")\n        return Sentence(\n            type=CONJ,\n            left=parse_sentence(left_str),\n            right=parse_sentence(right_str),\n        )\n\n    # Negation\n    if s.startswith(\"~\"):\n        sub_str = s[1:].strip()\n        if not sub_str:\n            raise ValueError(\"Negation with no operand\")\n        return Sentence(type=NEG, sub=parse_sentence(sub_str))\n\n    # Bare atom\n    return Sentence(type=ATOM, name=s)\n</code></pre>"},{"location":"api/syntax/#pynmms.syntax.is_atomic","title":"<code>pynmms.syntax.is_atomic(s)</code>","text":"<p>Return True if s parses to a bare atom (no logical connectives).</p> Source code in <code>pynmms/syntax.py</code> <pre><code>def is_atomic(s: str) -&gt; bool:\n    \"\"\"Return True if *s* parses to a bare atom (no logical connectives).\"\"\"\n    return parse_sentence(s).type == ATOM\n</code></pre>"},{"location":"api/syntax/#pynmms.syntax.all_atomic","title":"<code>pynmms.syntax.all_atomic(sentences)</code>","text":"<p>Return True if every sentence in sentences is atomic.</p> Source code in <code>pynmms/syntax.py</code> <pre><code>def all_atomic(sentences: frozenset[str]) -&gt; bool:\n    \"\"\"Return True if every sentence in *sentences* is atomic.\"\"\"\n    return all(is_atomic(s) for s in sentences)\n</code></pre>"},{"location":"theory/nmms-calculus/","title":"The NMMS Calculus","text":"<p>This page describes the theoretical foundations of pyNMMS, following Hlobil &amp; Brandom (2025), Chapter 3: \"Introducing Logical Vocabulary.\"</p>"},{"location":"theory/nmms-calculus/#overview","title":"Overview","text":"<p>NMMS (Non-Monotonic Multi-Succedent) is a sequent calculus for codifying open reason relations \u2014 consequence relations where Monotonicity ([Weakening]) and Transitivity ([Mixed-Cut]) can fail.</p>"},{"location":"theory/nmms-calculus/#material-base-definition-1","title":"Material Base (Definition 1)","text":"<p>A material base B =  consists of: <ul> <li>An atomic language L_B</li> <li>A base consequence relation |~_B \u2286 P(L_B) x P(L_B)</li> </ul> <p>satisfying Containment: Gamma \u2229 Delta \u2260 \u2205 implies Gamma |~_B Delta.</p> <p>The base encodes defeasible material inferences among atomic sentences as axioms.</p>"},{"location":"theory/nmms-calculus/#logical-extension","title":"Logical Extension","text":"<p>The rules of NMMS extend |~_B to a consequence relation |~ over a logically extended language L (adding ~, -&gt;, &amp;, |). A sequent Gamma =&gt; Delta is derivable iff there is a proof tree whose leaves are all axioms (base sequents).</p>"},{"location":"theory/nmms-calculus/#structural-rules-absent","title":"Structural Rules (Absent)","text":"<p>NMMS omits two structural rules:</p> <ul> <li>[Weakening]: Gamma |~ Delta does NOT imply Gamma, A |~ Delta. Adding premises can defeat inferences.</li> <li>[Mixed-Cut]: Gamma |~ A, Delta and Gamma', A |~ Delta' does NOT imply Gamma, Gamma' |~ Delta, Delta'. Chaining good inferences can yield bad ones.</li> </ul>"},{"location":"theory/nmms-calculus/#propositional-rules","title":"Propositional Rules","text":"<p>All rules are Ketonen-style. Multi-premise rules include a third top sequent containing all active formulae from the other premises on the same sides. This compensates for the absence of structural contraction.</p>"},{"location":"theory/nmms-calculus/#left-rules","title":"Left Rules","text":"<p>[L~] Negation left:</p> <pre><code>    Gamma =&gt; Delta, A\n    -----------------\n    Gamma, ~A =&gt; Delta\n</code></pre> <p>[L-&gt;] Implication left (3 premises):</p> <pre><code>    Gamma =&gt; Delta, A     Gamma, B =&gt; Delta     Gamma, B =&gt; Delta, A\n    -----------------------------------------------------------------\n                      Gamma, A -&gt; B =&gt; Delta\n</code></pre> <p>[L&amp;] Conjunction left:</p> <pre><code>    Gamma, A, B =&gt; Delta\n    --------------------\n    Gamma, A &amp; B =&gt; Delta\n</code></pre> <p>[L|] Disjunction left (3 premises):</p> <pre><code>    Gamma, A =&gt; Delta     Gamma, B =&gt; Delta     Gamma, A, B =&gt; Delta\n    -----------------------------------------------------------------\n                      Gamma, A | B =&gt; Delta\n</code></pre>"},{"location":"theory/nmms-calculus/#right-rules","title":"Right Rules","text":"<p>[R~] Negation right:</p> <pre><code>    Gamma, A =&gt; Delta\n    -----------------\n    Gamma =&gt; Delta, ~A\n</code></pre> <p>[R-&gt;] Implication right:</p> <pre><code>    Gamma, A =&gt; Delta, B\n    --------------------\n    Gamma =&gt; Delta, A -&gt; B\n</code></pre> <p>[R&amp;] Conjunction right (3 premises):</p> <pre><code>    Gamma =&gt; Delta, A     Gamma =&gt; Delta, B     Gamma =&gt; Delta, A, B\n    -----------------------------------------------------------------\n                      Gamma =&gt; Delta, A &amp; B\n</code></pre> <p>[R|] Disjunction right:</p> <pre><code>    Gamma =&gt; Delta, A, B\n    --------------------\n    Gamma =&gt; Delta, A | B\n</code></pre>"},{"location":"theory/nmms-calculus/#critical-properties","title":"Critical Properties","text":""},{"location":"theory/nmms-calculus/#supraclassicality-fact-2","title":"Supraclassicality (Fact 2)","text":"<p>CL \u2286 |~ \u2014 all classically valid sequents are derivable when the base obeys Containment. The \"narrowly logical part\" (derivable from Containment alone) is exactly classical propositional logic.</p>"},{"location":"theory/nmms-calculus/#conservative-extension-fact-3-prop-26","title":"Conservative Extension (Fact 3 / Prop. 26)","text":"<p>If Gamma \u222a Delta \u2286 L_B, then Gamma |~ Delta iff Gamma |~_B Delta. Adding logical vocabulary does not change base-level reason relations.</p>"},{"location":"theory/nmms-calculus/#invertibility-prop-27","title":"Invertibility (Prop. 27)","text":"<p>All NMMS rules are invertible \u2014 the bottom sequent is derivable iff all top sequents are derivable.</p>"},{"location":"theory/nmms-calculus/#projection-theorem-7","title":"Projection (Theorem 7)","text":"<p>Every sequent Gamma =&gt; Delta in the extended language uniquely decomposes into a set of base-vocabulary sequents (AtomicImp) such that Gamma =&gt; Delta is derivable iff AtomicImp \u2286 |~_B.</p>"},{"location":"theory/nmms-calculus/#explicitation-conditions","title":"Explicitation Conditions","text":"<p>These biconditionals show how logical vocabulary \"makes explicit\" reason relations:</p> <ul> <li>DD (Deduction-Detachment): Gamma |~ A -&gt; B, Delta iff Gamma, A |~ B, Delta</li> <li>II (Incoherence-Incompatibility): Gamma |~ ~A, Delta iff Gamma, A |~ Delta</li> <li>AA (Antecedent-Adjunction): Gamma, A &amp; B |~ Delta iff Gamma, A, B |~ Delta</li> <li>SS (Succedent-Summation): Gamma |~ A | B, Delta iff Gamma |~ A, B, Delta</li> </ul>"},{"location":"theory/nmms-calculus/#references","title":"References","text":"<ul> <li>Hlobil, U. &amp; Brandom, R. B. (2025). Reasons for Logic, Logic for Reasons. Chapter 3: \"Introducing Logical Vocabulary.\"</li> </ul>"},{"location":"tutorial/cli-usage/","title":"CLI Usage","text":""},{"location":"tutorial/cli-usage/#overview","title":"Overview","text":"<p>pyNMMS provides the <code>pynmms</code> command with three subcommands:</p> <pre><code>pynmms tell   # Add atoms or consequences to a base\npynmms ask    # Query derivability\npynmms repl   # Interactive REPL\n</code></pre>"},{"location":"tutorial/cli-usage/#pynmms-tell","title":"<code>pynmms tell</code>","text":"<p>Add atoms or consequences to a JSON base file.</p> <pre><code># Create a new base and add a consequence\npynmms tell -b base.json --create \"A |~ B\"\n\n# Add more consequences (base file must exist)\npynmms tell -b base.json \"B |~ C\"\n\n# Add atoms\npynmms tell -b base.json \"atom X\"\n</code></pre>"},{"location":"tutorial/cli-usage/#syntax","title":"Syntax","text":"<ul> <li>Consequence: <code>A |~ B</code> or <code>A, B |~ C, D</code> (comma-separated)</li> <li>Atom: <code>atom X</code></li> </ul>"},{"location":"tutorial/cli-usage/#pynmms-ask","title":"<code>pynmms ask</code>","text":"<p>Query whether a sequent is derivable.</p> <pre><code>pynmms ask -b base.json \"A =&gt; B\"\n# Output: DERIVABLE\n\npynmms ask -b base.json \"A =&gt; C\"\n# Output: NOT DERIVABLE\n</code></pre>"},{"location":"tutorial/cli-usage/#options","title":"Options","text":"<ul> <li><code>--trace</code>: Print the proof trace</li> <li><code>--max-depth N</code>: Set the maximum proof depth (default: 25)</li> </ul> <pre><code>pynmms ask -b base.json --trace \"=&gt; A -&gt; B\"\n# Output:\n# DERIVABLE\n#\n# Proof trace:\n#   [R\u2192] on A -&gt; B\n#     AXIOM: A =&gt; B\n#\n# Depth reached: 1\n# Cache hits: 0\n</code></pre>"},{"location":"tutorial/cli-usage/#pynmms-repl","title":"<code>pynmms repl</code>","text":"<p>Interactive REPL for exploring reason relations.</p> <pre><code>pynmms repl\npynmms repl -b base.json  # Load existing base\n</code></pre>"},{"location":"tutorial/cli-usage/#repl-commands","title":"REPL Commands","text":"Command Description <code>tell A \\|~ B</code> Add a consequence <code>tell atom A</code> Add an atom <code>ask A =&gt; B</code> Query derivability <code>show</code> Display the current base <code>trace on/off</code> Toggle proof trace display <code>save &lt;file&gt;</code> Save base to JSON <code>load &lt;file&gt;</code> Load base from JSON <code>help</code> Show available commands <code>quit</code> Exit the REPL"},{"location":"tutorial/cli-usage/#example-session","title":"Example Session","text":"<pre><code>$ pynmms repl\nStarting with empty base.\npyNMMS REPL. Type 'help' for commands.\n\npynmms&gt; tell A |~ B\nAdded: {'A'} |~ {'B'}\npynmms&gt; tell B |~ C\nAdded: {'B'} |~ {'C'}\npynmms&gt; ask A =&gt; B\nDERIVABLE\npynmms&gt; ask A =&gt; C\nNOT DERIVABLE\npynmms&gt; trace on\nTrace: ON\npynmms&gt; ask =&gt; A -&gt; B\nDERIVABLE\n  [R\u2192] on A -&gt; B\n    AXIOM: A =&gt; B\n  Depth: 1, Cache hits: 0\npynmms&gt; save mybase.json\nSaved to mybase.json\npynmms&gt; quit\n</code></pre>"},{"location":"tutorial/concepts/","title":"Key Concepts","text":""},{"location":"tutorial/concepts/#material-bases","title":"Material Bases","text":"<p>A material base B =  consists of: <ul> <li>L_B: An atomic language \u2014 a set of atomic sentence strings (e.g., <code>\"rain\"</code>, <code>\"wet_ground\"</code>)</li> <li>|~_B: A base consequence relation \u2014 a set of sequents (Gamma, Delta) where Gamma and Delta are sets of atomic sentences</li> </ul> <p>The base encodes defeasible material inferences: reasoning patterns that hold in normal circumstances but can be overridden by additional information.</p>"},{"location":"tutorial/concepts/#containment-axiom","title":"Containment Axiom","text":"<p>Every material base automatically satisfies Containment: if Gamma and Delta share any element (Gamma \u2229 Delta \u2260 \u2205), then Gamma |~_B Delta. This is the analogue of the identity axiom in classical logic.</p>"},{"location":"tutorial/concepts/#exact-match-no-weakening","title":"Exact Match (No Weakening)","text":"<p>Base consequences require exact syntactic match. If the base contains <code>{A} |~ {B}</code>, then <code>{A, C} |~ {B}</code> is not an axiom. This is what makes the system nonmonotonic \u2014 extra premises can defeat inferences.</p>"},{"location":"tutorial/concepts/#sequents","title":"Sequents","text":"<p>A sequent Gamma =&gt; Delta represents a reason relation: the sentences in Gamma (the antecedent) provide reason for at least one of the sentences in Delta (the succedent).</p> <ul> <li>Multi-succedent: Delta can contain multiple sentences. <code>Gamma =&gt; A, B</code> means \"Gamma provides reason for A-or-B.\"</li> <li>Empty antecedent: <code>=&gt; A</code> means A is unconditionally assertable.</li> <li>Empty succedent: <code>A =&gt;</code> means A is incoherent (leads to nothing).</li> </ul>"},{"location":"tutorial/concepts/#nonmonotonicity","title":"Nonmonotonicity","text":"<p>In NMMS, adding premises can defeat inferences. If <code>{rain} |~ {wet_ground}</code> but the base has no consequence from <code>{rain, covered}</code>, then:</p> <ul> <li><code>rain =&gt; wet_ground</code> is derivable</li> <li><code>rain, covered =&gt; wet_ground</code> is not derivable</li> </ul> <p>This models the everyday pattern: rain normally makes the ground wet, but if the ground is covered, the inference is defeated.</p>"},{"location":"tutorial/concepts/#nontransitivity","title":"Nontransitivity","text":"<p>NMMS also lacks Mixed-Cut (the structural rule for transitivity). Even if <code>A |~ B</code> and <code>B |~ C</code>, it does not follow that <code>A |~ C</code>. Each inference step must be independently justified by the base.</p>"},{"location":"tutorial/concepts/#supraclassicality","title":"Supraclassicality","text":"<p>Despite lacking Weakening and Mixed-Cut, NMMS is supraclassical: all classically valid sequents are derivable. The law of excluded middle (<code>=&gt; A | ~A</code>), double negation elimination (<code>~~A =&gt; A</code>), and all classical tautologies hold.</p>"},{"location":"tutorial/concepts/#explicitation-conditions","title":"Explicitation Conditions","text":"<p>The logical connectives \"make explicit\" reason relations through these biconditionals:</p> <ul> <li>DD (Deduction-Detachment): <code>Gamma |~ A -&gt; B, Delta</code> iff <code>Gamma, A |~ B, Delta</code></li> <li>II (Incoherence-Incompatibility): <code>Gamma |~ ~A, Delta</code> iff <code>Gamma, A |~ Delta</code></li> <li>AA (Antecedent-Adjunction): <code>Gamma, A &amp; B |~ Delta</code> iff <code>Gamma, A, B |~ Delta</code></li> <li>SS (Succedent-Summation): <code>Gamma |~ A | B, Delta</code> iff <code>Gamma |~ A, B, Delta</code></li> </ul>"},{"location":"tutorial/material-bases/","title":"Material Bases","text":""},{"location":"tutorial/material-bases/#creating-a-base","title":"Creating a Base","text":""},{"location":"tutorial/material-bases/#via-python-api","title":"Via Python API","text":"<pre><code>from pynmms import MaterialBase\n\n# From constructor\nbase = MaterialBase(\n    language={\"A\", \"B\", \"C\"},\n    consequences={\n        (frozenset({\"A\"}), frozenset({\"B\"})),\n        (frozenset({\"B\"}), frozenset({\"C\"})),\n    },\n)\n\n# Incrementally\nbase = MaterialBase()\nbase.add_atom(\"A\")\nbase.add_atom(\"B\")\nbase.add_consequence(frozenset({\"A\"}), frozenset({\"B\"}))\n</code></pre>"},{"location":"tutorial/material-bases/#via-cli","title":"Via CLI","text":"<pre><code>pynmms tell -b mybase.json --create \"atom A\"\npynmms tell -b mybase.json \"atom B\"\npynmms tell -b mybase.json \"A |~ B\"\n</code></pre>"},{"location":"tutorial/material-bases/#checking-axioms","title":"Checking Axioms","text":"<p>The <code>is_axiom</code> method checks whether a sequent is an axiom of the base:</p> <pre><code>base.is_axiom(frozenset({\"A\"}), frozenset({\"A\"}))  # True (Containment)\nbase.is_axiom(frozenset({\"A\"}), frozenset({\"B\"}))  # True (base consequence)\nbase.is_axiom(frozenset({\"A\", \"X\"}), frozenset({\"B\"}))  # False (no weakening)\n</code></pre>"},{"location":"tutorial/material-bases/#serialization","title":"Serialization","text":"<p>Bases can be saved to and loaded from JSON:</p> <pre><code># Save\nbase.to_file(\"mybase.json\")\n\n# Load\nbase = MaterialBase.from_file(\"mybase.json\")\n\n# Dict round-trip\ndata = base.to_dict()\nbase = MaterialBase.from_dict(data)\n</code></pre>"},{"location":"tutorial/material-bases/#json-format","title":"JSON Format","text":"<pre><code>{\n  \"language\": [\"A\", \"B\", \"C\"],\n  \"consequences\": [\n    {\"antecedent\": [\"A\"], \"consequent\": [\"B\"]},\n    {\"antecedent\": [\"B\"], \"consequent\": [\"C\"]}\n  ]\n}\n</code></pre>"},{"location":"tutorial/material-bases/#validation","title":"Validation","text":"<p>The base enforces that all sentences are atomic:</p> <pre><code># This raises ValueError:\nMaterialBase(language={\"~A\"})  # Negation is not atomic\nMaterialBase(consequences={(frozenset({\"A -&gt; B\"}), frozenset({\"C\"}))})  # Implication is not atomic\n</code></pre>"},{"location":"tutorial/proof-search/","title":"Proof Search","text":""},{"location":"tutorial/proof-search/#using-the-reasoner","title":"Using the Reasoner","text":"<pre><code>from pynmms import MaterialBase, NMMSReasoner\n\nbase = MaterialBase(\n    language={\"A\", \"B\"},\n    consequences={(frozenset({\"A\"}), frozenset({\"B\"}))},\n)\nreasoner = NMMSReasoner(base, max_depth=25)\n</code></pre>"},{"location":"tutorial/proof-search/#derives-full-result","title":"<code>derives()</code> \u2014 Full Result","text":"<pre><code>result = reasoner.derives(frozenset({\"A\"}), frozenset({\"B\"}))\nprint(result.derivable)      # True\nprint(result.trace)          # ['AXIOM: A =&gt; B']\nprint(result.depth_reached)  # 0\nprint(result.cache_hits)     # 0\n</code></pre>"},{"location":"tutorial/proof-search/#query-boolean-only","title":"<code>query()</code> \u2014 Boolean Only","text":"<pre><code>reasoner.query(frozenset({\"A\"}), frozenset({\"B\"}))  # True\n</code></pre>"},{"location":"tutorial/proof-search/#reading-proof-traces","title":"Reading Proof Traces","text":"<p>The trace records every rule application and axiom closure:</p> <pre><code>result = reasoner.derives(frozenset(), frozenset({\"A -&gt; B\"}))\nfor line in result.trace:\n    print(line)\n</code></pre> <p>Output: <pre><code>[R\u2192] on A -&gt; B\n  AXIOM: A =&gt; B\n</code></pre></p> <p>Trace entries include: - <code>AXIOM: Gamma =&gt; Delta</code> \u2014 leaf of the proof tree (base axiom or containment) - <code>[L\u00ac] on ~A</code> \u2014 left negation rule applied - <code>[L\u2192] on A -&gt; B</code> \u2014 left implication rule (3 premises) - <code>[L\u2227] on A &amp; B</code> \u2014 left conjunction rule - <code>[L\u2228] on A | B</code> \u2014 left disjunction rule (3 premises, Ketonen pattern) - <code>[R\u00ac] on ~A</code> \u2014 right negation rule - <code>[R\u2192] on A -&gt; B</code> \u2014 right implication rule - <code>[R\u2227] on A &amp; B</code> \u2014 right conjunction rule (3 premises, Ketonen pattern) - <code>[R\u2228] on A | B</code> \u2014 right disjunction rule - <code>FAIL: Gamma =&gt; Delta</code> \u2014 no rule could close this branch - <code>DEPTH LIMIT</code> \u2014 maximum proof depth exceeded</p>"},{"location":"tutorial/proof-search/#depth-limit","title":"Depth Limit","text":"<p>The <code>max_depth</code> parameter (default 25) prevents infinite proof search:</p> <pre><code>reasoner = NMMSReasoner(base, max_depth=10)\n</code></pre> <p>If the depth limit is reached, the proof search returns <code>False</code> for that branch.</p>"},{"location":"tutorial/proof-search/#memoization","title":"Memoization","text":"<p>The reasoner uses memoization to avoid re-proving identical subgoals. The <code>cache_hits</code> field in <code>ProofResult</code> reports how many times a cached result was reused.</p>"}]}